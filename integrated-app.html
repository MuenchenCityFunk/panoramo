// python -m http.server 8080
// python -m http.server 8080
//ngrok http 8080


<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Cloud Globe</title>
    <!-- <link rel="manifest" href="PWA globe/manifest.json"> -->
    <meta name="theme-color" content="#870050">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: "Helvetica Black", "Helvetica Neue", Helvetica, Arial, sans-serif;
            background: #000;
            text-transform: uppercase; /* Text in Gro√übuchstaben */
            letter-spacing: 0.1px; /* Buchstabenabstand vergr√∂√üern */
           /* font-stretch: expanded; /* Schrift horizontal strecken */
            font-weight: 600; /* Extra fett */
            text-shadow: 1px 1px 2px rgb(0, 0, 0); /* Schattierung */
            transform: scaleX(1); /* Horizontale Verzerrung */
            max-width: 100vw; /* Maximale Breite ist Bildschirmbreite */
            overflow-x: hidden; /* Horizontales Scrollen verhindern */
            word-wrap: break-word; /* W√∂rter umbrechen wenn n√∂tig */
            text-overflow: ellipsis; /* Text mit ... abschneiden wenn er zu lang ist */
            
        }

   
        #ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .btn {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            transition: background 0.3s ease;
            
            /* Text-Styling vom Body √ºbernehmen */
            font-family: "Helvetica Black", "Helvetica Neue", Helvetica, Arial, sans-serif;
            text-transform: uppercase; /* Text in Gro√übuchstaben */
            letter-spacing: 0.1px; /* Buchstabenabstand vergr√∂√üern */
            font-weight: 600; /* Extra fett */
            text-shadow: 2px 2px 4px rgb(255, 255, 255); /* Schattierung */
            transform: scaleX(1); /* Horizontale Verzerrung */
            word-wrap: break-word; /* W√∂rter umbrechen wenn n√∂tig */
            text-overflow: ellipsis; /* Text mit ... abschneiden wenn er zu lang ist */
        }
        
        .btn:hover {
            background: rgba(0,0,0,0.9);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #camera-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            display: none;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .camera-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        #volume-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgb(0, 0, 0);
            color: rgb(255, 255, 255);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 40px;
            z-index: 1001;
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }
        
        .status.info { background: rgba(0,123,255,0.8); }
        .status.success { background: rgba(40,167,69,0.8); }
        .status.error { background: rgba(220,53,69,0.8); }
        .status.processing { background: rgba(255,193,7,0.8); }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 40px;
            background: transparent;
            border-radius: 0px;
            outline: none;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            border-radius: 0%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            border-radius: 0%;
            cursor: pointer;
            box-shadow: none;
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            background: var(--slider-fill, linear-gradient(to right, 
                rgb(255, 255, 255) 0%, 
                rgb(255, 255, 255) 0%, 
                transparent 0%, 
                transparent 100%
            ));
            height: 20px;
            border-radius: 0px;
            border: 1px solid rgb(255, 255, 255);
        }
        
        input[type="range"]::-moz-range-track {
            background: var(--slider-fill, linear-gradient(to right, 
                rgb(255, 255, 255) 0%, 
                rgb(255, 255, 255) 0%, 
                transparent 0%, 
                transparent 100%
            ));
            height: 8px;
            border-radius: 0px;
            border: 1px solid rgb(255, 255, 255);
        }

        .video-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 0px;
            z-index: 1000;
            text-align: center;
        }

        #video-preview {
            width: 320px;
            height: 240px;
            border-radius: 0px;
            margin-bottom: 15px;
        }

        #recording-status {
            color: white;
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .video-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .video-controls .btn {
            padding: 10px 15px;
            font-size: 14px;
        }

        /* NEUE CSS-STYLES F√úR AUDIO-VISUALISIERUNG */
        #audio-visualization {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 1002;
            display: block;
        }
        
        /* Ph√§nomene-Kreis (kleiner innerer Kreis) */
        #phenomena-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Ph√§nomene-Labels */
        .phenomenon-label {
            position: absolute;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        #loud-label {
            top: 50%;
            right: -25px;
            transform: translateY(-50%);
        }
        
        #quiet-label {
            top: 50%;
            left: -25px;
            transform: translateY(-50%);
        }
        
        #scattered-label {
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #sorted-label {
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Gr√ºner Indikator-Punkt */
        #audio-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            border: 1px solid white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }
        
        /* Detailfenster */
        #audio-detail-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            z-index: 10000;
            display: none;
            cursor: grab;
        }
        
        #audio-detail-window:active {
            cursor: grabbing;
        }
        
        /* Schlie√üen-Button */
        #audio-detail-close {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }
        
        /* Gro√üer Parameter-Kreis */
        #parameter-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.2);
        }
        
        /* Parameter-Labels */
        .parameter-label {
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        #large-points-label {
            top: 50%;
            right: -80px;
            transform: translateY(-50%);
        }
        
        #small-points-label {
            top: 50%;
            left: -80px;
            transform: translateY(-50%);
        }
        
        #strong-distortion-label {
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #no-distortion-label {
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* NEUE CSS-STYLES F√úR DAS DETAILFENSTER */
        #audio-detail-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            z-index: 10000;
            display: none;
            cursor: grab;
        }
        
        #audio-detail-window:active {
            cursor: grabbing;
        }
        
        #audio-detail-window::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        
        #audio-detail-window::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        #detail-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .detail-labels {
            position: absolute;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .detail-label-left { left: 20px; top: 50%; transform: translateY(-50%); }
        .detail-label-right { right: 20px; top: 50%; transform: translateY(-50%); }
        .detail-label-top { top: 20px; left: 50%; transform: translateX(-50%); }
        .detail-label-bottom { bottom: 20px; left: 50%; transform: translateX(-50%); }
        
        #detail-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 10001;
        }
        
        #detail-close-btn:hover {
            background: rgba(255, 0, 0, 1);
        }
        
        #rotation-control {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 10px;
        }
        
        #rotation-slider {
            width: 200px;
            margin: 10px 0;
        }
        
        .rotation-step-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .rotation-step-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .rotation-step-btn.active {
            background: rgba(0, 255, 0, 0.5);
            border-color: rgba(0, 255, 0, 0.8);
        }

        /* NEUE CSS-STYLES F√úR DAS DETAILFENSTER MIT 8 BEGRIFFEN */
        #audio-detail-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            z-index: 10000;
            display: none;
            cursor: grab;
        }
        
        #audio-detail-window:active {
            cursor: grabbing;
        }
        
        #audio-detail-window::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        
        #audio-detail-window::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        #detail-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .detail-labels {
            position: absolute;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        /* NEU: 8 Positionen f√ºr die Labels */
        .detail-label-0 { left: 50%; top: 10px; transform: translateX(-50%); }      /* Oben */
        .detail-label-1 { right: 10px; top: 50%; transform: translateY(-50%); }     /* Rechts */
        .detail-label-2 { left: 50%; bottom: 10px; transform: translateX(-50%); }   /* Unten */
        .detail-label-3 { left: 10px; top: 50%; transform: translateY(-50%); }      /* Links */
        .detail-label-4 { right: 25%; top: 10px; transform: translateX(-50%); }     /* Oben-Rechts */
        .detail-label-5 { right: 10px; bottom: 25%; transform: translateY(-50%); }  /* Rechts-Unten */
        .detail-label-6 { left: 25%; bottom: 10px; transform: translateX(-50%); }   /* Unten-Links */
        .detail-label-7 { left: 10px; top: 25%; transform: translateY(-50%); }      /* Links-Oben */
        
        #detail-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 10001;
        }
        
        #detail-close-btn:hover {
            background: rgba(255, 0, 0, 1);
        }
        
        #rotation-control {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            font-size: 10px;
        }
        
        #rotation-slider {
            width: 200px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <!-- Am Anfang der Datei nach den globalen Variablen
    Pr√ºfe HTTPS-Status beim Laden -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            if (window.location.protocol !== 'https:' && 
                !window.location.hostname.includes('localhost') && 
                !window.location.hostname.includes('127.0.0.1')) {
                
                const warningDiv = document.createElement('div');
                warningDiv.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; 
                    background: #ff6b6b; color: white; padding: 10px; 
                    text-align: center; z-index: 9999; font-weight: bold;
                `;
                warningDiv.textContent = "‚ö†Ô∏è HTTPS erforderlich f√ºr Video-Aufnahme auf Mobilger√§ten!";
                document.body.appendChild(warningDiv);
            }
        });
    </script>

    <!-- Haupt-UI -->
    <div id="ui-overlay">
        <button class="btn" id="toggle-path-btn">ANTPATH</button>
        <button class="btn" id="center-camera-btn">HOMESICK?</button>
        <button class="btn" id="load-all-panoramas-btn">LOAD ALL</button>
        
        <!-- NEUE VIDEO-UPLOAD BUTTONS -->
        <button class="btn" id="record-video-btn">FOUND YOU</button>
        <button class="btn" id="upload-video-btn">REMEMBERED</button>
        
        <!-- NEUER BUTTON: Audio abspielen (in der Map) -->
        <button class="btn" id="play-audio-btn" style="display: none;">PLAY SOUND</button>
        
        <!-- Point Cloud Controls -->
        <div style="margin-top: 10px; background: rgba(0, 0, 0, 0.7); padding: 30px; border-radius: 0px; border: 0px solid rgba(255, 255, 255, 0.8)">
            <label for="pointSize" style="color: white; font-size: 10px; display: block; margin-bottom: 5px;">PNTS</label>
            <input type="range" id="pointSize" min="0.01" max="2.0" step="0.01" value="0.05" style="width: 150px; height: 40px;">
            <span id="pointSizeValue" style="color: white; font-size: 12px; margin-left: 10px;">0.05</span>
        </div>
    </div>
    
    <!-- Status-Anzeige -->
    <div id="status"></div>
    
    <!-- Kamera-UI (versteckt) -->
    <div id="camera-ui">
        <div class="camera-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas" style="display: none;"></canvas>
            <div id="volume-display">NOISE 0%</div>
            <div class="camera-controls">
                <button class="btn" id="capture-photo-btn" disabled>SCAN</button>
                <button class="btn" id="cancel-capture-btn">BACK</button>
            </div>
        </div>
    </div>

    <!-- NEUE VIDEO-AUFNAHME UI -->
    <div id="video-recording-ui" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1000;">
        <div class="video-container">
            <video id="video-preview" autoplay playsinline muted></video>
            <canvas id="video-canvas" style="display: none;"></canvas>
            <div id="recording-status">BEREIT ZUM AUFNEHMEN</div>
            <div class="video-controls">
                <button class="btn" id="start-recording-btn">START RECORDING</button>
                <button class="btn" id="stop-recording-btn" disabled>STOP RECORDING</button>
                <button class="btn" id="cancel-recording-btn">CANCEL</button>
                <!-- NEUER BUTTON: Audio abspielen -->
                <!-- <button class="btn" id="play-audio-btn" style="display: none;">PLAY SOUND</button> -->
            </div>
        </div>
    </div>

    <!-- NEUE AUDIO-VISUALISIERUNG -->
    <div id="audio-visualization">
        <div class="audio-labels audio-label-left">LEISE</div>
        <div class="audio-labels audio-label-right">LAUT</div>
        <div class="audio-labels audio-label-top">ZERSCHOSSEN</div>
        <div class="audio-labels audio-label-bottom">GLEICH</div>
        <div id="audio-indicator"></div>
    </div>

    <!-- NEUES DETAILFENSTER MIT 8 BEGRIFFEN -->
    <div id="audio-detail-window">
        <button id="detail-close-btn">√ó</button>
        
        <!-- NEU: 8 Labels die sich mit der Rotation bewegen -->
        <div class="detail-labels detail-label-0" data-original-text="KLEINE PUNKTE">KLEINE PUNKTE</div>
        <div class="detail-labels detail-label-1" data-original-text="GROSSE PUNKTE">GROSSE PUNKTE</div>
        <div class="detail-labels detail-label-2" data-original-text="SORTED">SORTED</div>
        <div class="detail-labels detail-label-3" data-original-text="SCATTERED">SCATTERED</div>
        <div class="detail-labels detail-label-4" data-original-text="FLACHE DEPTH">FLACHE DEPTH</div>
        <div class="detail-labels detail-label-5" data-original-text="STARKE DEPTH">STARKE DEPTH</div>
        <div class="detail-labels detail-label-6" data-original-text="GLEICH">GLEICH</div>
        <div class="detail-labels detail-label-7" data-original-text="ABWECHSELND">ABWECHSELND</div>
        
        <div id="detail-indicator"></div>
        
        <div id="rotation-control">
            <div>ROTATION: <span id="rotation-value">0¬∞</span></div>
            <input type="range" id="rotation-slider" min="0" max="270" value="0" step="90">
            <div style="margin: 10px 0;">
                <button class="rotation-step-btn active" data-angle="0">0¬∞</button>
                <button class="rotation-step-btn" data-angle="90">90¬∞</button>
                <button class="rotation-step-btn" data-angle="180">180¬∞</button>
                <button class="rotation-step-btn" data-angle="270">270¬∞</button>
            </div>
            <div style="font-size: 8px; margin-top: 5px;">Nur Vierteldrehungen erlaubt</div>
        </div>
    </div>

    <!-- Three.js Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>
    
    <script>
        // ===== GLOBALE VARIABLEN =====
        let stream = null;
        let audioStream = null;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let capturedImageData = null;
        let capturedDbLevel = 0;
        let userLocation = null;
        let userLocationObject = null;
        let userPath = [];
        let pathLine = null;
        let pathGeometry = null;
        let objectsToUpdate = [];
        let scanGPSLocation = null;
        let loadedPanoramas = []; // Neue Variable f√ºr geladene Panoramen
        
        // Neue globale Variablen f√ºr Video-Aufnahme
        let mediaRecorder = null;
        let recordedChunks = [];
        let videoStream = null;
        let isRecording = false;
        let recordingStartTime = null; // BEHALTE diese
        
        // NEUE GLOBALE VARIABLEN f√ºr Audio-Aufnahme
        let audioRecorder = null;
        let audioChunks = [];
        let recordedAudioBlob = null;
        let dbLevels = []; // Array f√ºr alle gemessenen Dezibel-Werte
        let dbMeasurementInterval = null;
        
        // NEUE GLOBALE VARIABLEN f√ºr Audio-Wiedergabe
        let audioPlayer = null;
        let currentAudioContext = null;
        let audioAnalyser = null;
        let audioSource = null;
        let isPlayingAudio = false;
        let audioPlaybackInterval = null;
        
        // NEUE GLOBALE FUNKTION (au√üerhalb aller anderen Funktionen)
        function getDeviceId() {
            let deviceId = localStorage.getItem('device_id');
            if (!deviceId) {
                deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('device_id', deviceId);
                console.log("üÜî Neue Device-ID erstellt:", deviceId);
            }
            return deviceId;
        }
        
        // Ersetze die FLASK_API_URL Definition
        // Automatische URL-Erkennung f√ºr Railway
        function getFlaskApiUrl() {
            const isLocalDevelopment = window.location.hostname === 'localhost' || 
                                     window.location.hostname === '127.0.0.1';
            
            if (isLocalDevelopment) {
                // Lokale Entwicklung - verwende separate Ports
                return 'http://localhost:5001/api';
            } else {
                // Railway - verwende relativen Pfad
                return '/api';
            }
        }
        
        const FLASK_API_URL = getFlaskApiUrl();
        console.log("Flask API URL:", FLASK_API_URL);
        
        // ===== THREE.JS SETUP =====
        const w = window.innerWidth;
        const h = window.innerHeight;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(w, h);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // Orbit Controls f√ºr bessere Sph√§re-Navigation konfigurieren
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        
        // Zoom-Limits f√ºr Sph√§re - erlaube sehr nahen Zoom
        controls.minDistance = 0.1;  // Kann sehr nah an die Sph√§re heranzoomen
        controls.maxDistance = 200;  // Kann weit herauszoomen
        
        // Rotation-Limits - erlaube vollst√§ndige Rotation
        controls.minPolarAngle = 0;   // Vollst√§ndige vertikale Rotation
        controls.maxPolarAngle = Math.PI;
        
        // Automatische Rotation deaktivieren
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0;
        
        // Smooth Zoom f√ºr bessere Navigation
        controls.enableZoom = true;
        controls.zoomSpeed = 1.0;
        
        // Panning f√ºr Navigation innerhalb der Sph√§re
        controls.enablePan = true;
        controls.panSpeed = 1.0;
        
        // ===== HILFSFUNKTIONEN =====
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }
        
        // ===== ANIMATION LOOP =====
        function animate() {
            requestAnimationFrame(animate);
            
            // Update alle Objekte
            objectsToUpdate.forEach(obj => {
                if (obj.update) obj.update();
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ===== EVENT LISTENERS =====
        document.getElementById('toggle-path-btn').addEventListener('click', togglePath);
        document.getElementById('center-camera-btn').addEventListener('click', centerCameraOnUser);
        document.getElementById('load-all-panoramas-btn').addEventListener('click', loadAllAvailablePanoramas);
        
        // Punktgr√∂√üen-Slider
        document.getElementById('pointSize').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('pointSizeValue').textContent = value.toFixed(2);
            
            // Update alle Point Clouds in der Szene
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    child.material.size = value;
                }
            });
            
            // NEU: Update Slider-F√ºllung
            updateSliderFill(e.target);
        });
        
        // NEUE FUNKTION: Slider-F√ºllung aktualisieren
        function updateSliderFill(slider) {
            const value = parseFloat(slider.value);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const percentage = ((value - min) / (max - min)) * 100;
            
            const fillGradient = `linear-gradient(to right, 
                rgb(255, 255, 255) 0%, 
                rgb(255, 255, 255) ${percentage}%, 
                transparent ${percentage}%, 
                transparent 100%
            )`;
            
            slider.style.setProperty('--slider-fill', fillGradient);
        }
        
        // NEU: Initialisiere Slider-F√ºllung beim Laden
        document.addEventListener('DOMContentLoaded', function() {
            const slider = document.getElementById('pointSize');
            updateSliderFill(slider);
        });
        
        // ===== KAMERA UND POINT CLOUD FUNKTIONEN =====
        
        // Kamera initialisieren
        async function initCamera() {
            try {
                showStatus("Kamera wird gestartet...", "info");
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: true
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                await video.play();
                
                // Mikrofon initialisieren
                await initMicrophone();
                startVolumeMonitoring();
                
                // Foto-Button aktivieren
                document.getElementById('capture-photo-btn').disabled = false;
                
                showStatus("Kamera bereit!", "success");
                console.log("Kamera erfolgreich gestartet");
                
            } catch (error) {
                console.error('Kamera Fehler:', error);
                showStatus('Kamera Fehler: ' + error.message, 'error');
            }
        }
        
        // Mikrofon initialisieren
        async function initMicrophone() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(audioStream);
                
                analyser.fftSize = 256;
                microphone.connect(analyser);
                
                console.log("Mikrofon erfolgreich initialisiert");
                
            } catch (error) {
                console.error('Mikrofon Fehler:', error);
                showStatus('Mikrofon Fehler: ' + error.message, 'error');
            }
        }
        
        // Lautst√§rke messen
        function measureVolume() {
            if (!analyser) return 0;
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            return (sum / dataArray.length) / 255;
        }
        
        // Lautst√§rke-Monitoring starten
        function startVolumeMonitoring() {
            const volumeDisplay = document.getElementById('volume-display');
            
            function updateVolume() {
                const volume = measureVolume();
                const db = Math.round(volume * 100);
                volumeDisplay.textContent = `üîä ${db}%`;
                
                if (volume > 0.7) {
                    volumeDisplay.style.background = 'rgba(255,0,0,0.8)';
                } else if (volume > 0.4) {
                    volumeDisplay.style.background = 'rgba(255,165,0,0.8)';
                } else {
                    volumeDisplay.style.background = 'rgba(0,0,0,0.7)';
                }
            }
            
            setInterval(updateVolume, 100);
        }
        
        // Foto aufnehmen
        function capturePhoto() {
            try {
                // GPS-Position beim Scannen speichern
                scanGPSLocation = userLocation; // Aktuelle GPS-Position speichern
                
                // Lautst√§rke beim Aufnehmen speichern
                capturedDbLevel = measureVolume();
                console.log('üì∏ Aufgenommene Lautst√§rke:', capturedDbLevel);
                console.log('üìç GPS-Position beim Scannen:', scanGPSLocation);
                
                const video = document.getElementById('video');
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                capturedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                showStatus("Foto aufgenommen! Generiere Point Cloud...", "processing");
                
                // Kamera stoppen
                stopCamera();
                
                // Point Cloud generieren und platzieren
                generateAndPlacePointCloud();
                
                // Zur√ºck zur Map
                document.getElementById('camera-ui').style.display = 'none';
                
            } catch (error) {
                console.error('Foto-Aufnahme Fehler:', error);
                showStatus('Foto-Aufnahme Fehler: ' + error.message, 'error');
            }
        }
        
        // Kamera stoppen
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        }
        
        // ===== EXAKTER POINT CLOUD GENERATOR (aus camera-app.html) =====
        
        // Point Cloud aus Bild generieren mit echten GPS-Koordinaten
        function generatePointCloudFromImage(imageData, dbLevel, gpsPosition) {
            const startTime = Date.now();
            console.log('üü° Starting Point Cloud generation...');
            console.log('üìç GPS-Position f√ºr Point Cloud:', gpsPosition);
            
            if (!imageData) {
                console.error('üî¥ No image data available!');
                showStatus('Kein Foto verf√ºgbar!', 'error');
                return null;
            }

            showStatus('Point Cloud wird generiert...', 'processing');
            
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const originalPixels = imageData.width * imageData.height;
            let defaultDownsample;

            if (originalPixels > 4000000) defaultDownsample = 15;      // 4MP+ -> 15x (2.7x besser)
            else if (originalPixels > 2000000) defaultDownsample = 10; // 2MP+ -> 10x (3x besser)  
            else if (originalPixels > 1000000) defaultDownsample = 7;  // 1MP+ -> 7x (2.9x besser)
            else defaultDownsample = 4;                                 // <1MP -> 4x (2.5x besser)
            
            const downsampleFactor = defaultDownsample;
            
            console.log('üìä Downsample factor:', downsampleFactor);
            console.log('üì± Is mobile:', isMobile);
            
            const downsampledImage = downsampleImageData(imageData, downsampleFactor);
            const depthMap = generateDepthMapData(downsampledImage);
            
            const width = downsampledImage.width;
            const height = downsampledImage.height;
            const numPoints = width * height;
            
            console.log('üìê Original size:', imageData.width, 'x', imageData.height);
            console.log('üìê Processed size:', width, 'x', height);
            console.log('üî¢ Total points:', numPoints.toLocaleString());
            
            const maxPoints = isMobile ? 300000 : 600000;
            if (numPoints > maxPoints) {
                console.error(' Too many points:', numPoints, '>', maxPoints);
                showStatus(`Zu viele Punkte (${numPoints.toLocaleString()})! Erh√∂hen Sie Downsample.`, 'error');
                return null;
            }
            
            const positions = new Float32Array(numPoints * 3);
            const colors = new Float32Array(numPoints * 3);
            
            let pointIndex = 0;
            
            // Progress-Update alle 1000 Punkte
            const progressInterval = Math.max(1, Math.floor(numPoints / 10));
            
            // GPS-Position in 3D-Koordinaten umwandeln
            const gps3DPosition = geoTo3D(gpsPosition.lat, gpsPosition.lon);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const pixelIndex = (y * width + x) * 4;
                    
                    const u = (x / width) - 0.5;    // -0.5 bis +0.5
                    const v = (y / height) - 0.5;   // -0.5 bis +0.5
                    
                    const r = downsampledImage.data[pixelIndex] / 255;
                    const g = downsampledImage.data[pixelIndex + 1] / 255;
                    const b = downsampledImage.data[pixelIndex + 2] / 255;
                    
                    const depth = depthMap[pixelIndex] / 255;
                    
                    // ECHTE GPS-KOORDINATEN verwenden
                    positions[pointIndex * 3] = gps3DPosition.x + (u * 2);           // GPS + Offset
                    positions[pointIndex * 3 + 1] = gps3DPosition.y + (-v * 2);      // GPS + Offset
                    positions[pointIndex * 3 + 2] = gps3DPosition.z + (depth * dbLevel * 2);
                    
                    colors[pointIndex * 3] = r;
                    colors[pointIndex * 3 + 1] = g;
                    colors[pointIndex * 3 + 2] = b;
                    
                    pointIndex++;
                    
                    if (pointIndex % progressInterval === 0) {
                        const progress = Math.round((pointIndex / numPoints) * 100);
                        showStatus(`Generierung: ${progress}%`, 'processing');
                    }
                }
            }
            
            const endTime = Date.now();
            console.log('üü¢ Point Cloud generation completed in:', endTime - startTime, 'ms');
            console.log('‚úÖ Points generated:', numPoints.toLocaleString());
            console.log('üìç Point Cloud Position:', gps3DPosition);
            
            return {
                positions: positions,
                colors: colors,
                count: numPoints,
                metadata: {
                    originalWidth: imageData.width,
                    originalHeight: imageData.height,
                    processedWidth: width,
                    processedHeight: height,
                    downsampleFactor: downsampleFactor,
                    depthIntensity: dbLevel * 2.5,
                    capturedVolume: dbLevel,
                    gpsPosition: gpsPosition,
                    gps3DPosition: gps3DPosition,
                    generatedAt: new Date().toISOString()
                }
            };
        }
        
        // Downsample Image Data (exakter Code aus camera-app.html)
        function downsampleImageData(imageData, factor) {
            const originalWidth = imageData.width;
            const originalHeight = imageData.height;
            const newWidth = Math.floor(originalWidth / factor);
            const newHeight = Math.floor(originalHeight / factor);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = originalWidth;
            tempCanvas.height = originalHeight;
            
            const tempImageData = new ImageData(
                new Uint8ClampedArray(imageData.data),
                originalWidth,
                originalHeight
            );
            tempCtx.putImageData(tempImageData, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0, newWidth, newHeight);
            
            return ctx.getImageData(0, 0, newWidth, newHeight);
        }
        
        // Depth Map Daten generieren (exakter Code aus camera-app.html)
        function generateDepthMapData(imageData) {
            const data = new Uint8ClampedArray(imageData.data);
            
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }
            
            return data;
        }
        
        // Point Cloud in Szene erstellen (angepasst f√ºr echte GPS-Koordinaten)
        function createPointCloudInScene(pointCloudData, position) {
            if (!pointCloudData) return;
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(pointCloudData.positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(pointCloudData.colors, 3));
            
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            
            const material = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });
            
            const pointCloud = new THREE.Points(geometry, material);
            pointCloud.position.set(0, 0, 0); // Keine zus√§tzliche Positionierung, da Punkte bereits GPS-Koordinaten haben
            pointCloud.scale.setScalar(0.5);
            
            scene.add(pointCloud);
            
            const pointCloudObject = {
                mesh: pointCloud,
                geometry: geometry,
                material: material,
                originalVertices: [...pointCloudData.positions],
                update: () => {
                    // Sanfte Rotation
                    // pointCloud.rotation.y += 0.001;
                }
            };
            
            objectsToUpdate.push(pointCloudObject);
            
            // Verbesserte Kamera-Positionierung f√ºr Panoramen
            if (pointCloudData.metadata && pointCloudData.metadata.gps3DPosition) {
                const gpsPos = pointCloudData.metadata.gps3DPosition;
                console.log("üéØ Zentriere Kamera auf Panorama bei:", gpsPos);
                
                // Kamera n√§her an das Panorama setzen
                camera.position.set(gpsPos.x + 10, gpsPos.y + 10, gpsPos.z + 10);
                camera.lookAt(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.target.set(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.update();
                
                console.log("üì∑ Kamera auf Panorama zentriert");
            } else {
                // Fallback f√ºr normale Point Clouds
                const gpsPos = pointCloudData.metadata.gps3DPosition;
                camera.position.set(gpsPos.x + 3, gpsPos.y + 3, gpsPos.z + 3);
                camera.lookAt(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.target.set(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.update();
            }
            
            console.log("Point Cloud zur Szene hinzugef√ºgt bei GPS-Position:", pointCloudData.metadata.gps3DPosition);
            console.log("Point Cloud Punkte:", pointCloudData.count);
            
            showStatus(`${pointCloudData.count.toLocaleString()} Punkte erstellt!`, 'success');
        }
        
        // Globale Variable f√ºr aktuelle Point Cloud
        let currentPointCloud = null;
        
        // Point Cloud generieren und platzieren
        function generateAndPlacePointCloud() {
            if (!capturedImageData || !scanGPSLocation) {
                showStatus("Keine Foto-Daten oder GPS-Position beim Scannen verf√ºgbar", "error");
                return;
            }
            
            showStatus("Point Cloud wird generiert...", "processing");
            
            // Point Cloud mit echten GPS-Koordinaten generieren
            const pointCloudData = generatePointCloudFromImage(capturedImageData, capturedDbLevel, scanGPSLocation);
            
            if (!pointCloudData) {
                showStatus("Point Cloud Generierung fehlgeschlagen", "error");
                return;
            }
            
            // Point Cloud in der Szene platzieren (Punkte haben bereits GPS-Koordinaten)
            createPointCloudInScene(pointCloudData, { x: 0, y: 0, z: 0 }); // Keine zus√§tzliche Positionierung
            
            // Aktuelle Point Cloud speichern
            currentPointCloud = pointCloudData;
        }
        
        // ===== GPS UND MAP FUNKTIONALIT√ÑT =====
        
        // GPS-Koordinaten zu 3D-Position umwandeln (mit H√∂he)
        function geoTo3D(lat, lon, altitude = 0) { 
            // Europa Bounding Box f√ºr Berlin/Paris Region
            const minLat = 35.0; // S√ºdlichster Punkt
            const maxLat = 70.0; // N√∂rdlichster Punkt
            const minLon = -10.0; // Westlichster Punkt
            const maxLon = 40.0;  // √ñstlichster Punkt
            
            // Normalisieren (0-1)
            const normalizedLat = (lat - minLat) / (maxLat - minLat);
            const normalizedLon = (lon - minLon) / (maxLon - minLon);
            
            // Zu 3D-Koordinaten mappen mit gr√∂√üerem Skalierungsfaktor
            const x = (normalizedLon - 0.5) * 100; // -50 bis +50
            const z = (normalizedLat - 0.5) * 100; // --50 bis +50
            const y = altitude / 10; // H√∂he in Metern, skaliert (10m = 1 Einheit)
            
            return { x, y, z };
        }
        
        // Benutzer-Position verfolgen (mit H√∂he)
        function getUserLocation() {
            if ("geolocation" in navigator) {
                console.log("GPS verf√ºgbar - starte Ortung...");
                showStatus("GPS wird initialisiert...", "info");
                
                // Path-Geometrie erstellen
                pathGeometry = new THREE.BufferGeometry();
                const pathMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 5,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Path-Line erstellen
                pathLine = new THREE.Line(pathGeometry, pathMaterial);
                scene.add(pathLine);
                
                // Position √ºberwachen
                const watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const newLocation = {
                            lat: position.coords.latitude,
                            lon: position.coords.longitude,
                            altitude: position.coords.altitude || 0 // H√∂he hinzuf√ºgen
                        };
                        
                        console.log("GPS Position erhalten:", newLocation);
                        console.log("GPS Genauigkeit:", position.coords.accuracy, "Meter");
                        console.log("GPS H√∂he:", position.coords.altitude, "Meter");
                        
                        // Benutzer-Position aktualisieren
                        userLocation = newLocation;
                        
                        // 3D-Position berechnen (mit H√∂he)
                        const pathPoint = geoTo3D(newLocation.lat, newLocation.lon, newLocation.altitude);
                        
                        // Pr√ºfen ob Bewegung signifikant ist (> 0.1 Einheiten)
                        let shouldAddPoint = true;
                        if (userPath.length > 0) {
                            const lastPoint = userPath[userPath.length - 1];
                            const distance = Math.sqrt(
                                Math.pow(pathPoint.x - lastPoint.x, 2) + 
                                Math.pow(pathPoint.y - lastPoint.y, 2) + 
                                Math.pow(pathPoint.z - lastPoint.z, 2)
                            );
                            
                            console.log("üìç Distanz:", distance.toFixed(6));
                            
                            // TEMPOR√ÑR: Alle Punkte hinzuf√ºgen
                            shouldAddPoint = true;
                            console.log("üìç Tempor√§r: Alle Punkte hinzuf√ºgen");
                        }
                        
                        if (shouldAddPoint) {
                            userPath.push(pathPoint);
                            console.log("Neuen Pfad-Punkt hinzugef√ºgt:", pathPoint);
                            console.log("Gesamte Pfad-Punkte:", userPath.length);
                            
                            // Pfad-Line aktualisieren
                            updatePathLine();
                        }
                        
                        // Benutzer-Objekt aktualisieren oder erstellen
                        if (userLocationObject) {
                            userLocationObject.mesh.position.set(pathPoint.x, pathPoint.y, pathPoint.z);
                            console.log("Benutzer-Objekt Position aktualisiert");
                        } else {
                            userLocationObject = createUserLocationObject(pathPoint);
                            scene.add(userLocationObject.mesh);
                            objectsToUpdate.push(userLocationObject);
                            console.log("Neues Benutzer-Objekt erstellt bei:", pathPoint);
                        }
                        
                        // Kamera beim ersten Mal auf Benutzer zentrieren
                        if (userPath.length === 1) {
                            camera.position.set(pathPoint.x + 5, pathPoint.y + 5, pathPoint.z + 5);
                            camera.lookAt(pathPoint.x, pathPoint.y, pathPoint.z);
                            controls.target.set(pathPoint.x, pathPoint.y, pathPoint.z);
                            controls.update();
                            console.log("Kamera auf Benutzer-Position zentriert");
                            showStatus("GPS aktiv! Position gefunden.", "success");
                        }
                    },
                    (error) => {
                        console.error("GPS Fehler:", error);
                        showStatus("GPS Fehler: " + error.message, "error");
                        
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                alert("Bitte erlaube Standortzugriff in deinen Browser-Einstellungen!");
                                break;
                            case error.POSITION_UNAVAILABLE:
                                alert("GPS-Position nicht verf√ºgbar. Pr√ºfe deine GPS-Einstellungen.");
                                break;
                            case error.TIMEOUT:
                                alert("GPS-Zeit√ºberschreitung. Versuche es nochmal.");
                                break;
                            default:
                                alert("Unbekannter GPS-Fehler: " + error.message);
                                break;
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 15000,
                        maximumAge: 0
                    }
                );
                
                // Watch-ID f√ºr sp√§teres Aufr√§umen speichern
                window.locationWatchId = watchId;
                console.log("GPS Watch gestartet mit ID:", watchId);
                
            } else {
                console.error("Geolocation nicht unterst√ºtzt");
                showStatus("GPS wird von deinem Browser nicht unterst√ºtzt.", "error");
            }
        }
        
        // Benutzer - Objekt erstellen
        function createUserLocationObject(position) {
            const vertices = [];
            const numPoints = 50; // Reduziert von 100 auf 50
            const size = 0.5; // Reduziert von 1 auf 0.5
            let x, y, z;

            // Punkte um (0,0,0) generieren (nur Offset, keine GPS-Koordinaten)
            for (let i = 0; i < numPoints; i += 1) {
                x = Math.random() * size - size * 0.5; // -0.25 bis +0.25
                y = Math.random() * size - size * 0.5;
                z = Math.random() * size - size * 0.5;
                vertices.push(x, y, z);
            }

            // Drei spezifische Punkte bei (0,0,0)
            vertices.push(
                0, 0, 0,           // Zentrum
                0, 0.5, 0,         // 0.5 nach oben (reduziert von 1)
                0, 0, 0.5          // 0.5 nach vorne (reduziert von 1)
            );

            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000, // Schwarz statt rot
                wireframe: true,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7 // Etwas weniger transparent
            });
            geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y, position.z); // GPS-Position setzen

            return { mesh };
        }
        
        // Pfad-Line aktualisieren
        function updatePathLine() {
            if (pathGeometry && userPath.length > 0) {
                const positions = [];
                userPath.forEach(point => {
                    positions.push(point.x, point.y, point.z);
                });
                
                pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                pathGeometry.attributes.position.needsUpdate = true;
                
                // Pfad-Line explizit sichtbar machen
                if (pathLine) {
                    pathLine.visible = true;
                    console.log("Pfad-Line sichtbar gemacht");
                }
            }
        }
        
        // Pfad ein-/ausschalten
        let pathVisible = true;
        function togglePath() {
            pathVisible = !pathVisible;
            if (pathLine) {
                pathLine.visible = pathVisible;
            }
            showStatus(`Pfad ${pathVisible ? 'eingeschaltet' : 'ausgeschaltet'}`, 'info');
        }
        
        // Kamera auf Benutzer zentrieren
        function centerCameraOnUser() {
            if (userLocation) {
                const position = geoTo3D(userLocation.lat, userLocation.lon);
                camera.position.set(position.x + 5, position.y + 5, position.z + 5);
                camera.lookAt(position.x, position.y, position.z);
                controls.target.set(position.x, position.y, position.z);
                controls.update();
                showStatus("Kamera auf Benutzer zentriert", "success");
            } else {
                showStatus("Keine GPS-Position verf√ºgbar", "error");
            }
        }
        
        // ===== PANORAMA LOADING FUNKTIONEN =====
        
        // Neue Funktion f√ºr 360¬∞ Panorama-Sph√§re mit Depth Map
        async function createPanoramaSphereFromDepthMap(imageUrl, depthMapUrl, metadata) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const depthImg = new Image();
                img.crossOrigin = "anonymous";
                depthImg.crossOrigin = "anonymous";
                
                let imageLoaded = false;
                let depthLoaded = false;
                
                const checkBothLoaded = () => {
                    if (imageLoaded && depthLoaded) {
                        createSpherePointCloud();
                    }
                };
                
                img.onload = () => {
                    imageLoaded = true;
                    checkBothLoaded();
                };
                
                depthImg.onload = () => {
                    depthLoaded = true;
                    checkBothLoaded();
                };
                
                img.onerror = () => reject(new Error("Konnte Panorama-Bild nicht laden"));
                depthImg.onerror = () => reject(new Error("Konnte Depth Map nicht laden"));
                
                img.src = imageUrl;
                depthImg.src = depthMapUrl;
                
                function createSpherePointCloud() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        ctx.drawImage(depthImg, 0, 0);
                        const depthData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        const gpsCoords = metadata.gps_coordinates;
                        const gps3DPosition = geoTo3D(gpsCoords.lat, gpsCoords.lon);
                        
                        const width = canvas.width;
                        const height = canvas.height;
                        const numPoints = width * height;
                        const positions = new Float32Array(numPoints * 3);
                        const colors = new Float32Array(numPoints * 3);
                        
                        // NEU: Audio-Analyse durchf√ºhren
                        let audioAnalysis = null;
                        if (dbLevels && dbLevels.length > 0) {
                            audioAnalysis = analyzeAudioData(dbLevels);
                            console.log("üéµ Audio-Analyse f√ºr Panorama:", audioAnalysis);
                            
                            // Audio-Visualisierung aktualisieren
                            updateAudioVisualization(audioAnalysis);
                        }
                        
                        // NEU: Audio-basierte Modifikationen (SENSIBLER)
                        let baseRadius = 25.0;
                        let depthInfluence = 8.0;
                        let pointSizeMultiplier = 1.0;
                        
                        if (audioAnalysis) {
                            // Punktgr√∂√üe basierend auf durchschnittlicher Lautst√§rke
                            // Leise = kleine Punkte (0.5x), Laut = gro√üe Punkte (2.0x)
                            pointSizeMultiplier = 0.5 + (audioAnalysis.volumeScore * 1.5);
                            
                            // NEU: SENSIBLERE Depth-Influence basierend auf Konsistenz
                            // Gleichm√§√üig = flacher (0.3x), Unterschiedlich = extremer (3.0x)
                            const depthMultiplier = 0.3 + ((1 - audioAnalysis.consistencyScore) * 2.7); // NEU: 0.3-3.0 statt 0.5-2.0
                            depthInfluence *= depthMultiplier;
                            
                            console.log(` Audio-Modifikationen (SENSIBEL):`);
                            console.log(`  Punktgr√∂√üe: ${pointSizeMultiplier.toFixed(2)}x`);
                            console.log(`  Depth-Influence: ${depthInfluence.toFixed(2)} (${depthMultiplier.toFixed(2)}x)`);
                        }
                        
                        // Bestehende Stitching-Statistiken
                        if (metadata.stitching_stats) {
                            const successfulFrames = metadata.stitching_stats.successful_frames;
                            const frameSteps = Math.floor(successfulFrames / 5);
                            baseRadius = Math.max(10.0, Math.min(50.0, 10.0 + (frameSteps * 5)));
                            
                            // NEU: Audio-Modifikationen mit Stitching kombinieren (SENSIBLER)
                            if (audioAnalysis) {
                                depthInfluence = Math.max(4.0, Math.min(16.0, 4.0 + (frameSteps * 2)));
                                // NEU: SENSIBLERE Depth-Multiplikation
                                const depthMultiplier = 0.3 + ((1 - audioAnalysis.consistencyScore) * 2.7); // NEU: 0.3-3.0
                                depthInfluence *= depthMultiplier;
                            } else {
                                depthInfluence = Math.max(4.0, Math.min(16.0, 4.0 + (frameSteps * 2)));
                            }
                            
                            console.log(` Stitching + Audio: Radius=${baseRadius.toFixed(1)}, Depth=${depthInfluence.toFixed(1)}`);
                        }
                        
                        let pointIndex = 0;
                        const progressInterval = Math.max(1, Math.floor(numPoints / 10));
                        
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const pixelIndex = (y * width + x) * 4;
                                
                                const u = (x / width) * 2 * Math.PI;
                                const v = (y / height) * Math.PI;
                                
                                const r = imageData.data[pixelIndex] / 255;
                                const g = imageData.data[pixelIndex + 1] / 255;
                                const b = imageData.data[pixelIndex + 2] / 255;
                                
                                const depth = depthData.data[pixelIndex] / 255;
                                
                                const depthRadius = baseRadius + (depth * depthInfluence);
                                
                                const sphereX = depthRadius * Math.sin(v) * Math.cos(u);
                                const sphereY = depthRadius * Math.cos(v);
                                const sphereZ = depthRadius * Math.sin(v) * Math.sin(u);
                                
                                positions[pointIndex * 3] = gps3DPosition.x + sphereX;
                                positions[pointIndex * 3 + 1] = gps3DPosition.y + sphereY;
                                positions[pointIndex * 3 + 2] = gps3DPosition.z + sphereZ;
                                
                                colors[pointIndex * 3] = r;
                                colors[pointIndex * 3 + 1] = g;
                                colors[pointIndex * 3 + 2] = b;
                                
                                pointIndex++;
                                
                                if (pointIndex % progressInterval === 0) {
                                    const progress = Math.round((pointIndex / numPoints) * 100);
                                    showStatus(`Sph√§re-Generierung: ${progress}%`, 'processing');
                                }
                            }
                        }
                        
                        const pointCloudData = {
                            positions: positions,
                            colors: colors,
                            count: numPoints,
                            metadata: {
                                ...metadata,
                                type: 'panorama_sphere',
                                baseRadius: baseRadius,
                                depthInfluence: depthInfluence,
                                gps3DPosition: gps3DPosition,
                                audioAnalysis: audioAnalysis, // NEU: Audio-Analyse speichern
                                pointSizeMultiplier: pointSizeMultiplier // NEU: Punktgr√∂√üen-Multiplikator
                            }
                        };
                        
                        // NEU: Audio-Modifikationen f√ºr aktuelle Point Cloud speichern
                        currentPanoramaAudioModifications = {
                            pointSizeMultiplier: pointSizeMultiplier,
                            audioAnalysis: audioAnalysis
                        };
                        
                        createPointCloudInScene(pointCloudData, { x: 0, y: 0, z: 0 });
                        
                        loadedPanoramas.push({
                            metadata: metadata,
                            pointCloudData: pointCloudData,
                            imageUrl: imageUrl,
                            depthMapUrl: depthMapUrl,
                            type: 'sphere',
                            audioAnalysis: audioAnalysis // NEU: Audio-Analyse hinzuf√ºgen
                        });
                        
                        console.log("‚úÖ 360¬∞ Panorama-Sph√§re mit Audio-Modifikationen erstellt");
                        console.log(" Sph√§re-Position:", gps3DPosition);
                        console.log("üîµ Sph√§re-Radius:", baseRadius);
                        if (audioAnalysis) {
                            console.log(" Audio-Modifikationen angewendet");
                        }
                        resolve();
                        
                    } catch (error) {
                        reject(error);
                    }
                }
            });
        }

        // Erweiterte Funktion zum Laden von Panorama mit Depth Map
        async function loadPanoramaFromServer() {
            let metadata;
            
            try {
                const deviceId = getDeviceId(); // NEU: Device-ID hinzuf√ºgen
                showStatus("Lade Panorama mit Depth Map vom Server...", "processing");
                
                // Metadaten laden - NEU: Device-spezifische URL
                const isLocalDevelopment = window.location.protocol === 'file:';
                let metadataUrl = isLocalDevelopment ? 
                    `./output/${deviceId}/panorama_metadata.json` : 
                    `${window.location.origin}/output/${deviceId}/panorama_metadata.json`;
                
                const metadataResponse = await fetch(metadataUrl);
                if (!metadataResponse.ok) {
                    // Fallback auf globale Metadaten
                    console.log("‚ö†Ô∏è Keine device-spezifischen Metadaten, verwende globale");
                    metadataUrl = isLocalDevelopment ? 
                        './output/panorama_metadata.json' : 
                        `${window.location.origin}/output/panorama_metadata.json`;
                    
                    const fallbackResponse = await fetch(metadataUrl);
                    if (!fallbackResponse.ok) {
                        throw new Error('Keine Panorama-Metadaten gefunden.');
                    }
                    metadata = await fallbackResponse.json();
                } else {
                    metadata = await metadataResponse.json();
                }
                
                console.log("‚úÖ Panorama-Metadaten geladen:", metadata);
                
                // Rest der Funktion bleibt gleich...
                // Pr√ºfe ob Depth Map existiert
                const depthMapFile = metadata.additional_files?.find(file => file.type === 'depth_map');
                if (!depthMapFile) {
                    throw new Error('Keine Depth Map gefunden. Verwende Standard-Point Cloud.');
                }
                
                // URLs f√ºr Panorama und Depth Map - NEU: Device-spezifische Pfade
                const panoramaUrl = isLocalDevelopment ? 
                    `./output/${deviceId}/${metadata.panorama_file}` : 
                    `${window.location.origin}/output/${deviceId}/${metadata.panorama_file}`;
                    
                const depthMapFileUrl = isLocalDevelopment ? 
                    `./output/${deviceId}/${depthMapFile.filename}` : 
                    `${window.location.origin}/output/${deviceId}/${depthMapFile.filename}`;
                
                // Pr√ºfe ob Dateien existieren
                const [panoramaResponse, depthMapResponse] = await Promise.all([
                    fetch(panoramaUrl),
                    fetch(depthMapFileUrl)
                ]);
                
                if (!panoramaResponse.ok) {
                    // Fallback auf globale Pfade
                    const globalPanoramaUrl = isLocalDevelopment ? 
                        `./output/${metadata.panorama_file}` : 
                        `${window.location.origin}/output/${metadata.panorama_file}`;
                    const globalDepthMapUrl = isLocalDevelopment ? 
                        `./output/${depthMapFile.filename}` : 
                        `${window.location.origin}/output/${depthMapFile.filename}`;
                    
                    const [globalPanoramaResponse, globalDepthMapResponse] = await Promise.all([
                        fetch(globalPanoramaUrl),
                        fetch(globalDepthMapUrl)
                    ]);
                    
                    if (!globalPanoramaResponse.ok) {
                        throw new Error(`Panorama-Datei nicht gefunden: ${metadata.panorama_file}`);
                    }
                    if (!globalDepthMapResponse.ok) {
                        throw new Error(`Depth Map nicht gefunden: ${depthMapFile.filename}`);
                    }
                    
                    // Verwende globale URLs
                    const panoramaBlob = await globalPanoramaResponse.blob();
                    const depthMapBlob = await globalDepthMapResponse.blob();
                    const imageUrl = URL.createObjectURL(panoramaBlob);
                    const depthMapBlobUrl = URL.createObjectURL(depthMapBlob);
                    
                    await createPanoramaSphereFromDepthMap(imageUrl, depthMapBlobUrl, metadata);
                } else {
                    // Verwende device-spezifische URLs
                    const panoramaBlob = await panoramaResponse.blob();
                    const depthMapBlob = await depthMapResponse.blob();
                    const imageUrl = URL.createObjectURL(panoramaBlob);
                    const depthMapBlobUrl = URL.createObjectURL(depthMapBlob);
                    
                    await createPanoramaSphereFromDepthMap(imageUrl, depthMapBlobUrl, metadata);
                }
                
                showStatus(`360¬∞ Panorama-Sph√§re erfolgreich geladen! (${metadata.image_width}x${metadata.image_height})`, "success");
                
            } catch (error) {
                console.error("‚ùå Fehler beim Laden des Panoramas:", error);
                showStatus(`Fehler: ${error.message}`, "error");
            }
        }
        
        // Point Cloud aus Panorama-Bild erstellen
        async function createPointCloudFromPanorama(imageUrl, metadata) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                
                img.onload = () => {
                    try {
                        // Erstelle Canvas und lade Bild
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        // Hole Bilddaten
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // GPS-Koordinaten aus Metadaten
                        const gpsCoords = metadata.gps_coordinates;
                        console.log("üìç GPS-Koordinaten f√ºr Panorama:", gpsCoords);
                        
                        // Erstelle Point Cloud mit GPS-Koordinaten
                        const pointCloudData = generatePointCloudFromImage(
                            imageData, 
                            0.5, // Standard-Lautst√§rke f√ºr Panoramen
                            { lat: gpsCoords.lat, lon: gpsCoords.lon }
                        );
                        
                        if (pointCloudData) {
                            // Point Cloud in Szene platzieren
                            createPointCloudInScene(pointCloudData, { x: 0, y: 0, z: 0 });
                            
                            // Zur Liste der geladenen Panoramen hinzuf√ºgen
                            loadedPanoramas.push({
                                metadata: metadata,
                                pointCloudData: pointCloudData,
                                imageUrl: imageUrl
                            });
                            
                            console.log("‚úÖ Panorama-Point Cloud erfolgreich erstellt");
                            resolve();
                        } else {
                            reject(new Error("Point Cloud Generierung fehlgeschlagen"));
                        }
                        
                    } catch (error) {
                        reject(error);
                    }
                };
                
                img.onerror = () => {
                    reject(new Error("Konnte Panorama-Bild nicht laden"));
                };
                
                img.src = imageUrl;
            });
        }

        // Neue Funktion: Lade alle verf√ºgbaren Panoramen
        async function loadAllAvailablePanoramas() {
            try {
                const deviceId = getDeviceId(); // NEU
                showStatus("Lade alle verf√ºgbaren Panoramen...", "processing");
                
                const isLocalDevelopment = window.location.protocol === 'file:';
                
                // NEU: Device-spezifische Metadaten-URL
                let metadataUrl = isLocalDevelopment ? 
                    `./output/${deviceId}/panorama_metadata.json` : 
                    `${window.location.origin}/output/${deviceId}/panorama_metadata.json`;
                
                // Fallback auf globale Metadaten wenn device-spezifische nicht existiert
                const metadataResponse = await fetch(metadataUrl);
                if (!metadataResponse.ok) {
                    console.log("‚ö†Ô∏è Keine device-spezifischen Panoramen gefunden, verwende globale");
                    metadataUrl = isLocalDevelopment ? 
                        './output/panorama_metadata.json' : 
                        `${window.location.origin}/output/panorama_metadata.json`;
                }
                
                const metadata = await metadataResponse.json();
                console.log("üìÑ Haupt-Metadaten geladen:", metadata);
                
                // Lade das Hauptpanorama aus den Metadaten
                await loadSpecificPanorama(metadata);
                
                // Dynamisch alle verf√ºgbaren Panoramen aus den Metadaten extrahieren
                const panoramaFiles = [];
                
                // F√ºge das Hauptpanorama hinzu
                if (metadata.panorama_file) {
                    panoramaFiles.push(metadata.panorama_file);
                }
                
                // F√ºge alle zus√§tzlichen Panoramen aus den Metadaten hinzu
                if (metadata.additional_files) {
                    metadata.additional_files.forEach(file => {
                        if (file.type === 'depth_map') {
                            // Konvertiere depth_map Dateiname zu panorama Dateiname
                            const panoramaName = file.filename.replace('depth_map_', '').replace('.png', '');
                            const panoramaFile = `${panoramaName}.jpg`;
                            if (!panoramaFiles.includes(panoramaFile)) {
                                panoramaFiles.push(panoramaFile);
                            }
                        }
                    });
                }
                
                console.log("üîç Gefundene Panorama-Dateien:", panoramaFiles);
                
                let loadedCount = 1; // Hauptpanorama bereits geladen
                
                for (const panoramaFile of panoramaFiles) {
                    // √úberspringe das Hauptpanorama, da es bereits geladen wurde
                    if (panoramaFile === metadata.panorama_file) {
                        console.log(`‚è≠Ô∏è  √úberspringe Hauptpanorama: ${panoramaFile}`);
                        continue;
                    }
                    
                    const panoramaUrl = isLocalDevelopment ? 
                        `./output/${panoramaFile}` : 
                        `${window.location.origin}/output/${panoramaFile}`;
                    
                    // Pr√ºfe ob Panorama existiert
                    console.log(`üîç Pr√ºfe Panorama: ${panoramaUrl}`);
                    const panoramaResponse = await fetch(panoramaUrl);
                    if (panoramaResponse.ok) {
                        console.log(`‚úÖ Panorama gefunden: ${panoramaFile}`);
                        
                        const panoramaName = panoramaFile.replace('.jpg', '');
                        const depthMapFile = `depth_map_${panoramaName}.png`;
                        const depthMapUrl = isLocalDevelopment ? 
                            `./output/${depthMapFile}` : 
                            `${window.location.origin}/output/${depthMapFile}`;
                        
                        // Pr√ºfe ob Depth Map existiert
                        console.log(`üîç Pr√ºfe Depth Map: ${depthMapUrl}`);
                        const depthMapResponse = await fetch(depthMapUrl);
                        if (depthMapResponse.ok) {
                            console.log(`‚úÖ Depth Map gefunden: ${depthMapFile}`);
                            console.log(`üéØ Lade zus√§tzliches Panorama: ${panoramaFile}`);
                            
                            try {
                                const panoramaBlob = await panoramaResponse.blob();
                                const depthMapBlob = await depthMapResponse.blob();
                                const imageUrl = URL.createObjectURL(panoramaBlob);
                                const depthMapBlobUrl = URL.createObjectURL(depthMapBlob);
                                
                                // Erstelle Metadaten f√ºr dieses Panorama
                                const additionalMetadata = {
                                    panorama_file: panoramaFile,
                                    additional_files: [{
                                        filename: depthMapFile,
                                        type: 'depth_map'
                                    }],
                                    gps_coordinates: metadata.gps_coordinates, // Verwende GPS vom Hauptpanorama
                                    created_at: new Date().toISOString(),
                                    image_width: 1750, // Beispiel-Werte
                                    image_height: 471
                                };
                                
                                await createPanoramaSphereFromDepthMap(imageUrl, depthMapBlobUrl, additionalMetadata);
                                loadedCount++;
                                
                            } catch (error) {
                                console.error(`‚ö†Ô∏è  Fehler beim Laden von ${panoramaFile}:`, error);
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è  Depth Map nicht gefunden: ${depthMapFile} (Status: ${depthMapResponse.status})`);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è  Panorama nicht gefunden: ${panoramaFile} (Status: ${panoramaResponse.status})`);
                    }
                }
                
                showStatus(`${loadedCount} Panoramen erfolgreich geladen!`, "success");
                
            } catch (error) {
                console.error("‚ùå Fehler beim Laden aller Panoramen:", error);
                showStatus(`Fehler: ${error.message}`, "error");
            }
        }

        // Ersetze die alte autoLoadPanoramas Funktion
        async function autoLoadPanoramas() {
            try {
                console.log("üîÑ Lade alle verf√ºgbaren Panoramen...");
                await loadAllAvailablePanoramas();
            } catch (error) {
                console.log("‚ÑπÔ∏è  Keine Panoramen verf√ºgbar:", error.message);
            }
        }
        
        // ===== INITIALISIERUNG =====
        camera.position.set(10, 10, 10);
        controls.update();
        
        // GPS starten
        getUserLocation();
        
        // Automatisch Panoramen vom Server laden und Kamera positionieren
        autoLoadPanoramasAndPositionCamera();
        
        // Starte Animation
        animate();
        
        // Zeige Status
        showStatus('App bereit! GPS wird initialisiert...', 'info');
        
        // Neue Funktion: Lade Panoramen und positioniere Kamera
        async function autoLoadPanoramasAndPositionCamera() {
            try {
                console.log("üîÑ Lade alle verf√ºgbaren Panoramen...");
                await loadAllAvailablePanoramas();
                
                // Nach dem Laden aller Panoramen: Kamera auf neuestes Panorama positionieren
                if (loadedPanoramas.length > 0) {
                    // Neuestes Panorama finden (basierend auf created_at)
                    const newestPanorama = loadedPanoramas.reduce((newest, current) => {
                        const newestTime = new Date(newest.metadata.created_at || 0);
                        const currentTime = new Date(current.metadata.created_at || 0);
                        return currentTime > newestTime ? current : newest;
                    });
                    
                    if (newestPanorama && newestPanorama.pointCloudData && newestPanorama.pointCloudData.metadata) {
                        const gpsPos = newestPanorama.pointCloudData.metadata.gps3DPosition;
                        console.log("üéØ Positioniere Kamera auf neuestes Panorama:", gpsPos);
                        
                        // Kamera mitten in die Point Cloud setzen
                        camera.position.set(gpsPos.x, gpsPos.y, gpsPos.z);
                        camera.lookAt(gpsPos.x + 1, gpsPos.y, gpsPos.z); // Leicht nach vorne schauen
                        controls.target.set(gpsPos.x + 1, gpsPos.y, gpsPos.z);
                        controls.update();
                        
                        console.log("üì∑ Kamera mitten in der neuesten Point Cloud positioniert");
                        showStatus("Kamera auf neuestes Panorama ausgerichtet", "success");
                    }
                }
            } catch (error) {
                console.log("‚ÑπÔ∏è  Keine Panoramen verf√ºgbar:", error.message);
            }
        }

        // Ersetze die alte autoLoadPanoramas Funktion
        async function autoLoadPanoramas() {
            try {
                console.log("üîÑ Lade alle verf√ºgbaren Panoramen...");
                await loadAllAvailablePanoramas();
            } catch (error) {
                console.log("‚ÑπÔ∏è  Keine Panoramen verf√ºgbar:", error.message);
            }
        }

        // Debug-Funktion hinzuf√ºgen
        async function debugServerConnection() {
            const serverUrl = window.location.origin;
            const deviceId = getDeviceId(); // NEU: Device-ID hinzuf√ºgen
            console.log("üîç Debug Server-Verbindung...");
            console.log("üìç Server URL:", serverUrl);
            console.log("üÜî Device ID:", deviceId); // NEU: Device-ID loggen
            
            try {
                // NEU: Erst device-spezifische Metadaten testen
                const deviceMetadataUrl = `${serverUrl}/output/${deviceId}/panorama_metadata.json`;
                console.log("üîç Teste Device-Metadaten-URL:", deviceMetadataUrl);
                
                const deviceResponse = await fetch(deviceMetadataUrl);
                console.log("‚úÖ Device Response Status:", deviceResponse.status);
                
                if (deviceResponse.ok) {
                    const deviceMetadata = await deviceResponse.json();
                    console.log("üìÑ Device-Metadaten:", deviceMetadata);
                } else {
                    // Fallback auf globale Metadaten
                    const metadataUrl = `${serverUrl}/output/panorama_metadata.json`;
                    console.log("üîç Teste globale Metadaten-URL:", metadataUrl);
                    
                    const response = await fetch(metadataUrl);
                    console.log("‚úÖ Globale Response Status:", response.status);
                    
                    if (response.ok) {
                        const metadata = await response.json();
                        console.log("üìÑ Globale Metadaten:", metadata);
                    }
                }
            } catch (error) {
                console.error("‚ùå Debug-Fehler:", error);
            }
        }

        // Debug beim Laden ausf√ºhren
        debugServerConnection();

        // Erweiterte Orbit Controls f√ºr Sph√§re-Navigation
        function setupEnhancedOrbitControls() {
            // Bestehende Controls erweitern
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            
            // Zoom-Limits f√ºr Sph√§re
            controls.minDistance = 0.1;  // Kann in die Sph√§re hineinzoomen
            controls.maxDistance = 100;  // Kann weit herauszoomen
            
            // Rotation-Limits
            controls.minPolarAngle = 0;   // Vollst√§ndige vertikale Rotation
            controls.maxPolarAngle = Math.PI;
            
            // Automatische Rotation deaktivieren (Sph√§re dreht sich nicht von selbst)
            controls.autoRotate = false;
            controls.autoRotateSpeed = 0;
            
            // Smooth Zoom f√ºr bessere Navigation
            controls.enableZoom = true;
            controls.zoomSpeed = 1.0;
            
            // Panning f√ºr Navigation innerhalb der Sph√§re
            controls.enablePan = true;
            controls.panSpeed = 1.0;
            
            console.log("üéÆ Erweiterte Orbit Controls f√ºr 360¬∞ Sph√§re aktiviert");
        }

        // In der Initialisierung
        function init() {
            // ... bestehender Code ...
            
            // Erweiterte Controls aktivieren
            setupEnhancedOrbitControls();
            
            // Automatisch Panoramen vom Server laden
            autoLoadPanoramas();
            
            // NEU: Audio-Visualisierung initialisieren
            initAudioVisualization();
            
            // ... restlicher Code ...
        }

        // NEU: Initialisierung beim DOM-Load
        document.addEventListener('DOMContentLoaded', function() {
            // ... bestehender Code ...
            
            // Audio-Visualisierung sofort anzeigen
            initAudioVisualization();
        });

        // Erweiterte Video-Aufnahme mit Audio
        async function initVideoRecording() {
            try {
                showStatus("Initialisiere Video-Aufnahme...", "processing");
                
                const videoPreview = document.getElementById('video-preview');
                if (!videoPreview) {
                    throw new Error("Video-Element nicht gefunden");
                }
                
                // Pr√ºfe HTTPS auf Mobilger√§ten
                if (window.location.protocol !== 'https:' && !window.location.hostname.includes('localhost')) {
                    throw new Error("HTTPS erforderlich f√ºr Video-Aufnahme auf Mobilger√§ten");
                }
                
                // Pr√ºfe Browser-Unterst√ºtzung
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("Video-Aufnahme wird von diesem Browser nicht unterst√ºtzt");
                }
                
                // NEU: Video UND Audio Stream anfordern
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        facingMode: 'environment',
                        frameRate: { ideal: 30, max: 60 }
                    },
                    audio: true // NEU: Audio aktivieren
                });
                
                videoStream = stream;
                videoPreview.srcObject = stream;
                
                const videoUI = document.getElementById('video-recording-ui');
                if (videoUI) {
                    videoUI.style.display = 'block';
                }
                
                showStatus("Video-Aufnahme bereit!", "success");
                
            } catch (error) {
                console.error("Video-Aufnahme Fehler:", error);
                let errorMessage = error.message;
                
                // Benutzerfreundliche Fehlermeldungen
                if (error.name === 'NotAllowedError') {
                    errorMessage = "Kamera-Zugriff verweigert. Bitte erlauben Sie den Zugriff auf die Kamera.";
                } else if (error.name === 'NotFoundError') {
                    errorMessage = "Keine Kamera gefunden. Bitte pr√ºfen Sie, ob eine Kamera verf√ºgbar ist.";
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = "Video-Aufnahme wird von diesem Ger√§t nicht unterst√ºtzt.";
                } else if (error.name === 'NotReadableError') {
                    errorMessage = "Kamera wird bereits von einer anderen Anwendung verwendet.";
                }
                
                showStatus(`Video-Aufnahme Fehler: ${errorMessage}`, "error");
            }
        }

        // NEUE FUNKTION: Dezibel-Messung w√§hrend der Aufnahme
        function startDbMeasurement() {
            if (!videoStream) return;
            
            // Audio-Context f√ºr Dezibel-Messung erstellen
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            const microphone = audioContext.createMediaStreamSource(videoStream);
            
            analyser.fftSize = 256;
            microphone.connect(analyser);
            
            dbLevels = []; // Array zur√ºcksetzen
            recordingStartTime = Date.now();
            
            dbMeasurementInterval = setInterval(() => {
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                const dbLevel = (sum / dataArray.length) / 255;
                
                // Zeitstempel und Dezibel-Wert speichern
                const timestamp = Date.now() - recordingStartTime;
                dbLevels.push({
                    timestamp: timestamp,
                    dbLevel: dbLevel
                });
                
                // Live-Anzeige aktualisieren
                const dbDisplay = document.getElementById('recording-status');
                if (dbDisplay) {
                    const dbPercent = Math.round(dbLevel * 100);
                    dbDisplay.textContent = `AUFNAHME L√ÑUFT... üîä ${dbPercent}%`;
                }
                
                console.log(`üîä DB Level: ${dbLevel.toFixed(3)} (${dbPercent}%)`);
            }, 100); // Alle 100ms messen
            
            console.log("üé§ Dezibel-Messung gestartet");
        }

        // NEUE FUNKTION: Dezibel-Messung stoppen
        function stopDbMeasurement() {
            if (dbMeasurementInterval) {
                clearInterval(dbMeasurementInterval);
                dbMeasurementInterval = null;
            }
            console.log("üé§ Dezibel-Messung gestoppt. Gesammelte Werte:", dbLevels.length);
        }

        // Erweiterte Video-Aufnahme starten
        function startVideoRecording() {
            if (!videoStream) {
                showStatus("Kein Video-Stream verf√ºgbar. Bitte initialisieren Sie die Aufnahme zuerst.", "error");
                return;
            }
            
            try {
                recordedChunks = [];
                audioChunks = []; // NEU: Audio-Chunks zur√ºcksetzen
                
                // Unterst√ºtzte Codecs f√ºr Mobilger√§te pr√ºfen
                const supportedTypes = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm',
                    'video/mp4',
                    'video/ogg;codecs=theora'
                ];
                
                let selectedType = null;
                for (const type of supportedTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        selectedType = type;
                        console.log("Verwende Codec:", type);
                        break;
                    }
                }
                
                if (!selectedType) {
                    throw new Error("Kein unterst√ºtzter Video-Codec gefunden");
                }
                
                mediaRecorder = new MediaRecorder(videoStream, {
                    mimeType: selectedType
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const videoBlob = new Blob(recordedChunks, { type: selectedType });
                    console.log("Video aufgenommen:", videoBlob.size, "bytes");
                    
                    // NEU: Audio-Blob aus Video extrahieren
                    recordedAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    console.log("Audio extrahiert:", recordedAudioBlob.size, "bytes");
                    
                    // NEU: PLAY SOUND Button in der Map anzeigen (nicht im Aufnahmefenster)
                    document.getElementById('play-audio-btn').style.display = 'inline-block';
                    
                    showStatus("Video aufgenommen! Bereit zum Upload.", "success");
                    prepareVideoForUpload(videoBlob);
                };
                
                mediaRecorder.onerror = (event) => {
                    console.error("MediaRecorder Fehler:", event.error);
                    showStatus(`Aufnahme-Fehler: ${event.error.message}`, "error");
                };
                
                // NEU: Dezibel-Messung starten
                startDbMeasurement();
                
                // Aufnahme mit kleineren Chunks f√ºr bessere Kompatibilit√§t
                mediaRecorder.start(1000); // 1 Sekunde Chunks
                isRecording = true;
                recordingStartTime = Date.now();
                
                document.getElementById('start-recording-btn').disabled = true;
                document.getElementById('stop-recording-btn').disabled = false;
                document.getElementById('recording-status').textContent = "AUFNAHME L√ÑUFT... üîä 0%";
                
                showStatus("Video-Aufnahme gestartet...", "processing");
                
            } catch (error) {
                console.error("Aufnahme-Fehler:", error);
                showStatus(`Aufnahme fehlgeschlagen: ${error.message}`, "error");
            }
        }

        // Erweiterte Video-Aufnahme stoppen
        function stopVideoRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                // NEU: Dezibel-Messung stoppen
                stopDbMeasurement();
                
                const duration = Date.now() - recordingStartTime;
                console.log("Aufnahme gestoppt. Dauer:", duration, "ms");
                console.log("Gesammelte DB-Level:", dbLevels.length);
                
                document.getElementById('start-recording-btn').disabled = false;
                document.getElementById('stop-recording-btn').disabled = true;
                document.getElementById('recording-status').textContent = "AUFNAHME BEENDET";
            }
        }

        // NEUE FUNKTION: Audio abspielen
        function playRecordedAudio() {
            if (!recordedAudioBlob || !dbLevels.length) {
                showStatus("Kein Audio oder DB-Daten verf√ºgbar", "error");
                return;
            }
            
            try {
                if (isPlayingAudio) {
                    stopAudioPlayback();
                    return;
                }
                
                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                audioPlayer = new Audio(audioUrl);
                
                // NEU: Audio-Eigenschaften f√ºr mobile Kompatibilit√§t
                audioPlayer.preload = 'auto';
                audioPlayer.volume = 1.0;
                audioPlayer.muted = false;
                
                // NEU: Audio-Context f√ºr Echtzeit-Analyse
                currentAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioAnalyser = currentAudioContext.createAnalyser();
                audioSource = currentAudioContext.createMediaElementSource(audioPlayer);
                
                // NEU: Verbindungen herstellen
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(currentAudioContext.destination);
                
                audioAnalyser.fftSize = 256;
                
                let playbackStartTime = Date.now();
                let currentDbIndex = 0;
                
                // NEU: Zeitbasierte DB-Map f√ºr Animation
                const recordingDuration = dbLevels[dbLevels.length - 1].timestamp - dbLevels[0].timestamp;
                const timeBasedDbMap = analyzeTimeBasedAudioData(dbLevels, recordingDuration);
                
                // NEU: Audio-Event-Listener f√ºr bessere Kontrolle
                audioPlayer.addEventListener('canplaythrough', () => {
                    console.log("‚úÖ Audio bereit zum Abspielen");
                });
                
                audioPlayer.addEventListener('error', (error) => {
                    console.error("‚ùå Audio-Fehler:", error);
                    // NEU: Keine Status-Anzeige bei Audio-Fehlern
                });
                
                audioPlaybackInterval = setInterval(() => {
                    const currentTime = Date.now() - playbackStartTime;
                    
                    // NEU: Dynamische Animation basierend auf aktueller Zeit
                    animatePointCloudWithAudio(currentTime, timeBasedDbMap, recordingDuration);
                    
                    // Finde den passenden DB-Level f√ºr die aktuelle Zeit
                    while (currentDbIndex < dbLevels.length && 
                           dbLevels[currentDbIndex].timestamp < currentTime) {
                        currentDbIndex++;
                    }
                    
                    if (currentDbIndex < dbLevels.length) {
                        const currentDb = dbLevels[currentDbIndex].dbLevel;
                        
                        // NEU: Erweiterte Audio-Animation
                        if (currentDb > 0.6) {
                            console.log(` Audio Playback: DB=${currentDb.toFixed(3)}, Zeit=${(currentTime/1000).toFixed(1)}s`);
                        }
                    }
                }, 50);
                
                audioPlayer.addEventListener('ended', () => {
                    stopAudioPlayback();
                    showStatus("Audio-Wiedergabe beendet", "info");
                });
                
                // NEU: Audio direkt abspielen - KEINE BERECHTIGUNGSANFRAGE
                audioPlayer.play().then(() => {
                    isPlayingAudio = true;
                    showStatus("Audio wird abgespielt...", "success");
                    console.log("‚úÖ Audio erfolgreich gestartet");
                }).catch(playError => {
                    console.error("‚ùå Audio-Play fehlgeschlagen:", playError);
                    
                    // NEU: KEINE Fallback-Mechanismen - einfach ignorieren
                    console.log("‚ö†Ô∏è Audio-Autoplay blockiert - ignoriere");
                    
                    // NEU: Trotzdem Animation starten (ohne Audio)
                    if (timeBasedDbMap) {
                        console.log("üéµ Starte Animation ohne Audio...");
                        startAnimationWithoutAudio(timeBasedDbMap, recordingDuration);
                    }
                });
                
            } catch (error) {
                console.error("Audio-Wiedergabe Fehler:", error);
                // NEU: Keine Status-Anzeige bei Fehlern
            }
        }

        // NEUE FUNKTION: Animation ohne Audio
        function startAnimationWithoutAudio(timeBasedDbMap, recordingDuration) {
            console.log("üé¨ Starte Animation ohne Audio-Playback");
            
            let animationStartTime = Date.now();
            let currentDbIndex = 0;
            
            // NEU: Animation-Interval ohne Audio
            const animationInterval = setInterval(() => {
                const currentTime = Date.now() - animationStartTime;
                
                // NEU: Dynamische Animation basierend auf aktueller Zeit
                animatePointCloudWithAudio(currentTime, timeBasedDbMap, recordingDuration);
                
                // Finde den passenden DB-Level f√ºr die aktuelle Zeit
                while (currentDbIndex < dbLevels.length && 
                       dbLevels[currentDbIndex].timestamp < currentTime) {
                    currentDbIndex++;
                }
                
                if (currentDbIndex < dbLevels.length) {
                    const currentDb = dbLevels[currentDbIndex].dbLevel;
                    
                    if (currentDb > 0.6) {
                        console.log(`üé¨ Animation: DB=${currentDb.toFixed(3)}, Zeit=${(currentTime/1000).toFixed(1)}s`);
                    }
                }
                
                // NEU: Animation stoppen nach Aufnahmedauer
                if (currentTime >= recordingDuration) {
                    clearInterval(animationInterval);
                    console.log("üé¨ Animation beendet");
                    showStatus("Animation beendet", "info");
                }
            }, 50);
            
            // NEU: Animation-Interval speichern f√ºr sp√§teres Stoppen
            window.animationInterval = animationInterval;
        }

        // MODIFIZIERTE FUNKTION: Audio-Wiedergabe stoppen (erweitert f√ºr Animation)
        function stopAudioPlayback() {
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer = null;
            }
            
            if (audioPlaybackInterval) {
                clearInterval(audioPlaybackInterval);
                audioPlaybackInterval = null;
            }
            
            // NEU: Auch Animation-Interval stoppen
            if (window.animationInterval) {
                clearInterval(window.animationInterval);
                window.animationInterval = null;
            }
            
            if (currentAudioContext) {
                currentAudioContext.close();
                currentAudioContext = null;
            }
            
            // NEU: Point Clouds zur√ºcksetzen
            scene.children.forEach(child => {
                if (child.type === 'Points') {
                    child.rotation.set(0, 0, 0);
                    child.scale.setScalar(1.0);
                    child.position.set(0, 0, 0);
                }
            });
            
            isPlayingAudio = false;
            console.log("Audio-Wiedergabe und Animation gestoppt");
        }

        // NEUE FUNKTION: Depth Map basierend auf Audio animieren
        function animateDepthMapWithAudio(dbLevel) {
            // Finde alle Point Clouds in der Szene
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    // DB-Level in Verzerrung umwandeln
                    // Laut = mehr Verzerrung, Leise = weniger Verzerrung
                    const distortionFactor = Math.max(0.5, Math.min(2.0, 1.0 + (dbLevel * 2)));
                    
                    // Scale basierend auf DB-Level anpassen
                    child.scale.setScalar(distortionFactor);
                    
                    // Zus√§tzliche Rotation f√ºr laute Ger√§usche
                    if (dbLevel > 0.7) {
                        child.rotation.y += 0.01;
                    }
                }
            });
        }

        // Neue Funktion: Video Recording UI schlie√üen
        function closeVideoRecordingUI() {
            const videoUI = document.getElementById('video-recording-ui');
            if (videoUI) {
                videoUI.style.display = 'none';
            }
            
            // Video Stream stoppen falls noch aktiv
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            
            // Recording Status zur√ºcksetzen
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
            }
            
            // NEU: Audio-Visualisierung auf Standard-Position setzen
            resetAudioVisualization();
            
            // UI-Elemente zur√ºcksetzen
            const startBtn = document.getElementById('start-recording-btn');
            const stopBtn = document.getElementById('stop-recording-btn');
            const statusEl = document.getElementById('recording-status');
            
            if (startBtn) startBtn.disabled = false;
            if (stopBtn) stopBtn.disabled = true;
            if (statusEl) statusEl.textContent = "BEREIT ZUR AUFNAHME";
            
            console.log("Video Recording UI geschlossen");
        }

        // Globale Variable f√ºr das aktuelle Upload-Session
        let currentUploadSession = null;

        // Fehlende globale Variable f√ºr Status-Polling
        let statusPollingInterval = null;

        async function prepareVideoForUpload(videoBlob) {
            try {
                const gpsPosition = await getCurrentGPSPosition();
                
                // Eindeutige Session-ID f√ºr diesen Upload erstellen
                currentUploadSession = {
                    id: Date.now().toString(),
                    uploadTime: new Date(),
                    gpsPosition: gpsPosition
                };
                
                const formData = new FormData();
                formData.append('video', videoBlob, 'recorded_video.webm');
                formData.append('gps_lat', gpsPosition.lat);
                formData.append('gps_lon', gpsPosition.lon);
                formData.append('session_id', currentUploadSession.id);
                
                // NEUE ZEILEN:
                const deviceId = getDeviceId();
                formData.append('device_id', deviceId);
                
                showStatus("Lade Video hoch...", "processing");
                
                const response = await fetch(`${FLASK_API_URL}/upload-video`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Upload fehlgeschlagen: ${response.status}`);
                }
                
                const result = await response.json();
                console.log("Upload erfolgreich:", result);
                
                showStatus("Video hochgeladen! Panorama wird erstellt...", "success");
                startPanoramaStatusPolling();
                
            } catch (error) {
                console.error("Upload-Fehler:", error);
                showStatus(`Upload fehlgeschlagen: ${error.message}`, "error");
            }
        }

        function startPanoramaStatusPolling() {
            if (statusPollingInterval) {
                clearInterval(statusPollingInterval);
            }
            
            let retryCount = 0;
            const maxRetries = 100; // Erh√∂ht von 30 auf 60 (3 Minuten)
            const uploadStartTime = new Date();
            
            statusPollingInterval = setInterval(async () => {
                try {
                    retryCount++;
                    console.log(`Status-Check ${retryCount}/${maxRetries}`);
                    
                    // NEU: Device-ID verwenden
                    const deviceId = getDeviceId();
                    
                    // Direkt die Metadaten-Datei pr√ºfen statt Server-Status
                    const isLocalDevelopment = window.location.protocol === 'file:';
                    
                    // NEU: Erst device-spezifische Metadaten pr√ºfen
                    let metadataUrl = isLocalDevelopment ? 
                        `./output/${deviceId}/panorama_metadata.json` : 
                        `${window.location.origin}/output/${deviceId}/panorama_metadata.json`;
                    
                    let metadataResponse = await fetch(metadataUrl);
                    
                    // NEU: Fallback auf globale Metadaten wenn device-spezifische nicht existiert
                    if (!metadataResponse.ok) {
                        console.log("‚ö†Ô∏è Keine device-spezifischen Metadaten, pr√ºfe globale");
                        metadataUrl = isLocalDevelopment ? 
                            './output/panorama_metadata.json' : 
                            `${window.location.origin}/output/panorama_metadata.json`;
                        metadataResponse = await fetch(metadataUrl);
                    }
                    
                    if (metadataResponse.ok) {
                        const metadata = await metadataResponse.json();
                        
                        // Pr√ºfe ob das Panorama nach unserem Upload erstellt wurde
                        const panoramaTime = new Date(metadata.created_at);
                        const timeDiff = panoramaTime - uploadStartTime;
                        const minutesDiff = timeDiff / (1000 * 60);
                        
                        console.log("üïê Panorama erstellt nach Upload:", minutesDiff.toFixed(1), "Minuten");
                        
                        // Wenn das Panorama nach unserem Upload erstellt wurde
                        if (timeDiff > 0 && minutesDiff < 15) { // Erh√∂ht von 10 auf 15 Minuten
                            clearInterval(statusPollingInterval);
                            statusPollingInterval = null;
                            
                            console.log("‚úÖ Neues Panorama gefunden:", metadata);
                            showStatus("Neues Panorama gefunden! Lade in Map...", "success");
                            
                            closeVideoRecordingUI();
                            
                            // Lade das neue Panorama
                            await loadSpecificPanorama(metadata);
                            
                        } else if (timeDiff < 0) {
                            // Panorama ist √§lter als unser Upload
                            showStatus(`Warte auf neues Panorama... (${retryCount}/${maxRetries})`, "processing");
                        } else {
                            // Panorama ist zu neu (m√∂glicherweise noch in Bearbeitung)
                            showStatus(`Panorama wird erstellt... (${retryCount}/${maxRetries})`, "processing");
                        }
                    } else {
                        // Keine Metadaten-Datei gefunden
                        showStatus(`Warte auf Panorama... (${retryCount}/${maxRetries})`, "processing");
                    }
                    
                    if (retryCount >= maxRetries) {
                        clearInterval(statusPollingInterval);
                        statusPollingInterval = null;
                        showStatus("Panorama-Erstellung dauert zu lange. Versuche es sp√§ter.", "error");
                    }
                    
                } catch (error) {
                    console.error("Status-Polling Fehler:", error);
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        clearInterval(statusPollingInterval);
                        statusPollingInterval = null;
                        showStatus("Verbindungsfehler. Versuche es sp√§ter.", "error");
                    }
                }
            }, 5000); // Erh√∂ht von 3000 auf 5000ms (5 Sekunden zwischen Checks)
        }

        // Vereinfachte loadSpecificPanorama Funktion (ohne strenge Validierung)
        async function loadSpecificPanorama(metadata) {
            try {
                const deviceId = getDeviceId(); // NEU: Device-ID hinzuf√ºgen
                showStatus("Lade neues Panorama...", "processing");
                
                console.log("üéØ Lade neues Panorama:", metadata);
                
                const isLocalDevelopment = window.location.protocol === 'file:';
                
                const depthMapFile = metadata.additional_files?.find(file => file.type === 'depth_map');
                if (!depthMapFile) {
                    throw new Error('Keine Depth Map gefunden. Verwende Standard-Point Cloud.');
                }
                
                // NEU: Device-spezifische URLs
                const panoramaUrl = isLocalDevelopment ? 
                    `./output/${deviceId}/${metadata.panorama_file}` : 
                    `${window.location.origin}/output/${deviceId}/${metadata.panorama_file}`;
                    
                const depthMapFileUrl = isLocalDevelopment ? 
                    `./output/${deviceId}/${depthMapFile.filename}` : 
                    `${window.location.origin}/output/${deviceId}/${depthMapFile.filename}`;
                
                const [panoramaResponse, depthMapResponse] = await Promise.all([
                    fetch(panoramaUrl),
                    fetch(depthMapFileUrl)
                ]);
                
                if (!panoramaResponse.ok || !depthMapResponse.ok) {
                    // NEU: Fallback auf globale Pfade
                    console.log("‚ö†Ô∏è Device-spezifische Dateien nicht gefunden, verwende globale");
                    const globalPanoramaUrl = isLocalDevelopment ? 
                        `./output/${metadata.panorama_file}` : 
                        `${window.location.origin}/output/${metadata.panorama_file}`;
                    const globalDepthMapUrl = isLocalDevelopment ? 
                        `./output/${depthMapFile.filename}` : 
                        `${window.location.origin}/output/${depthMapFile.filename}`;
                    
                    const [globalPanoramaResponse, globalDepthMapResponse] = await Promise.all([
                        fetch(globalPanoramaUrl),
                        fetch(globalDepthMapUrl)
                    ]);
                    
                    if (!globalPanoramaResponse.ok) {
                        throw new Error(`Panorama-Datei nicht gefunden: ${metadata.panorama_file}`);
                    }
                    if (!globalDepthMapResponse.ok) {
                        throw new Error(`Depth Map nicht gefunden: ${depthMapFile.filename}`);
                    }
                    
                    showStatus("Erstelle 360¬∞ Panorama-Sph√§re mit Depth Map...", "processing");
                    
                    const panoramaBlob = await globalPanoramaResponse.blob();
                    const depthMapBlob = await globalDepthMapResponse.blob();
                    const imageUrl = URL.createObjectURL(panoramaBlob);
                    const depthMapBlobUrl = URL.createObjectURL(depthMapBlob);
                    
                    await createPanoramaSphereFromDepthMap(imageUrl, depthMapBlobUrl, metadata);
                } else {
                    showStatus("Erstelle 360¬∞ Panorama-Sph√§re mit Depth Map...", "processing");
                    
                    const panoramaBlob = await panoramaResponse.blob();
                    const depthMapBlob = await depthMapResponse.blob();
                    const imageUrl = URL.createObjectURL(panoramaBlob);
                    const depthMapBlobUrl = URL.createObjectURL(depthMapBlob);
                    
                    await createPanoramaSphereFromDepthMap(imageUrl, depthMapBlobUrl, metadata);
                }
                
                showStatus(`Neues 360¬∞ Panorama geladen! (${metadata.image_width}x${metadata.image_height})`, "success");
                
                // Session zur√ºcksetzen
                currentUploadSession = null;
                
            } catch (error) {
                console.error("‚ùå Fehler beim Laden des Panoramas:", error);
                showStatus(`Fehler: ${error.message}`, "error");
            }
        }

        // Fehlende Funktion: Aktuelle GPS-Position abrufen
        async function getCurrentGPSPosition() {
            return new Promise((resolve, reject) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            resolve({
                                lat: position.coords.latitude,
                                lon: position.coords.longitude,
                                accuracy: position.coords.accuracy
                            });
                        },
                        (error) => {
                            console.warn("GPS nicht verf√ºgbar:", error);
                            // Fallback auf Berlin-Koordinaten
                            resolve({
                                lat: 52.52,
                                lon: 13.405,
                                accuracy: 10000
                            });
                        },
                        { 
                            timeout: 15000,
                            enableHighAccuracy: false,
                            maximumAge: 30000
                        }
                    );
                } else {
                    reject(new Error("Geolocation nicht unterst√ºtzt"));
                }
            });
        }

        // Event Listeners f√ºr neue Buttons
        document.getElementById('record-video-btn').addEventListener('click', initVideoRecording);
        document.getElementById('start-recording-btn').addEventListener('click', startVideoRecording);
        document.getElementById('stop-recording-btn').addEventListener('click', stopVideoRecording);
        document.getElementById('cancel-recording-btn').addEventListener('click', cancelVideoRecording);
        document.getElementById('upload-video-btn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await prepareVideoForUpload(file);
                }
            };
            input.click();
        });
        document.getElementById('play-audio-btn').addEventListener('click', playRecordedAudio); // NEU

        // Neuer Event Listener f√ºr alle Panoramen
        document.getElementById('load-all-panoramas-btn').addEventListener('click', loadAllAvailablePanoramas);

        // Debug-Funktion f√ºr Browser-Capabilities
        function logBrowserCapabilities() {
            console.log("=== Browser Capabilities ===");
            console.log("User Agent:", navigator.userAgent);
            console.log("HTTPS:", window.location.protocol === 'https:');
            console.log("MediaDevices:", !!navigator.mediaDevices);
            console.log("getUserMedia:", !!navigator.mediaDevices?.getUserMedia);
            console.log("MediaRecorder:", !!window.MediaRecorder);
            
            if (window.MediaRecorder) {
                const codecs = [
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm',
                    'video/mp4',
                    'video/ogg;codecs=theora'
                ];
                
                codecs.forEach(codec => {
                    console.log(`${codec}:`, MediaRecorder.isTypeSupported(codec));
                });
            }
        }
        
        // Beim Laden ausf√ºhren
        document.addEventListener('DOMContentLoaded', logBrowserCapabilities);

        function cancelVideoRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
            }
            
            // NEU: Dezibel-Messung stoppen falls aktiv
            stopDbMeasurement();
            
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            
            document.getElementById('video-recording-ui').style.display = 'none';
            showStatus("Video-Aufnahme abgebrochen", "info");
        }

        // NEUE GLOBALE VARIABLEN f√ºr Audio-Analyse
        let audioAnalysisData = null;
        let currentPanoramaAudioModifications = null;

        // NEUE FUNKTION: Audio-Daten analysieren (SENSIBLER)
        function analyzeAudioData(dbLevels) {
            if (!dbLevels || dbLevels.length === 0) {
                return null;
            }
            
            // Durchschnittliche Lautst√§rke berechnen
            const avgDb = dbLevels.reduce((sum, entry) => sum + entry.dbLevel, 0) / dbLevels.length;
            
            // Varianz der Lautst√§rke berechnen (f√ºr Konsistenz)
            const variance = dbLevels.reduce((sum, entry) => {
                const diff = entry.dbLevel - avgDb;
                return sum + (diff * diff);
            }, 0) / dbLevels.length;
            
            // Standardabweichung
            const stdDev = Math.sqrt(variance);
            
            // NEU: SENSIBLERE Konsistenz-Berechnung
            // Verwende einen kleineren Divisor f√ºr empfindlichere Reaktion
            const consistencyScore = Math.max(0, 1 - (stdDev / (avgDb * 0.3))); // NEU: 0.3 statt 1.0
            
            // Normalisierte Werte f√ºr die Visualisierung
            const volumeScore = Math.min(1, avgDb * 2); // 0-1 Skala
            const consistencyScoreNormalized = consistencyScore; // Bereits 0-1
            
            console.log("üéµ Audio-Analyse (SENSIBEL):");
            console.log("  Durchschnittliche DB:", avgDb.toFixed(3));
            console.log("  Standardabweichung:", stdDev.toFixed(3));
            console.log("  Konsistenz-Score:", consistencyScore.toFixed(3));
            console.log("  Volume-Score:", volumeScore.toFixed(3));
            
            return {
                averageDb: avgDb,
                standardDeviation: stdDev,
                consistencyScore: consistencyScore,
                volumeScore: volumeScore,
                consistencyScoreNormalized: consistencyScoreNormalized,
                totalSamples: dbLevels.length
            };
        }

        // NEUE FUNKTION: Audio-Visualisierung aktualisieren (IMMER ANZEIGEN)
        function updateAudioVisualization(analysisData) {
            const visualization = document.getElementById('audio-visualization');
            const indicator = document.getElementById('audio-indicator');
            
            if (!visualization || !indicator) return;
            
            // NEU: Standard-Position wenn keine Audio-Daten
            let x = 0.5; // Mitte
            let y = 0.5; // Mitte
            
            if (analysisData) {
                // Position im Koordinatensystem berechnen
                // X-Achse: Leise (links) -> Laut (rechts)
                // Y-Achse: Gleich (unten) -> Zerschossen (oben)
                x = analysisData.volumeScore; // 0-1
                y = 1 - analysisData.consistencyScoreNormalized; // 0-1 (umgekehrt)
            }
            
            // Position im Kreis berechnen (0-1 zu -1 bis 1)
            const circleX = (x - 0.5) * 2; // -1 bis 1
            const circleY = (y - 0.5) * 2; // -1 bis 1
            
            // Auf Kreis begrenzen
            const distance = Math.sqrt(circleX * circleX + circleY * circleY);
            const clampedX = distance > 1 ? circleX / distance : circleX;
            const clampedY = distance > 1 ? circleY / distance : circleY;
            
            // Position in Pixeln (innerer Kreis = 40px Radius)
            const pixelX = clampedX * 40;
            const pixelY = clampedY * 40;
            
            // Farbe basierend auf Position
            const hue = x * 120; // Gr√ºn (leise) -> Rot (laut)
            const saturation = 80 + (y * 20); // 80-100%
            const lightness = 50 + (y * 20); // 50-70%
            
            indicator.style.transform = `translate(calc(-50% + ${pixelX}px), calc(-50% + ${pixelY}px))`;
            indicator.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // NEU: Immer anzeigen
            visualization.style.display = 'block';
            
            if (analysisData) {
                console.log(`üéØ Audio-Visualisierung: X=${x.toFixed(2)}, Y=${y.toFixed(2)}, Position=(${pixelX.toFixed(1)}, ${pixelY.toFixed(1)})`);
            } else {
                console.log(`üéØ Audio-Visualisierung: Standard-Position (keine Audio-Daten)`);
            }
        }

        // NEUE FUNKTION: Audio-Visualisierung initialisieren (beim Laden)
        function initAudioVisualization() {
            const audioViz = document.getElementById('audio-visualization');
            if (!audioViz) {
                console.error("‚ùå Audio-Visualisierung Element nicht gefunden");
                return;
            }
            
            // NEU: HTML f√ºr das Koordinatensystem erstellen
            audioViz.innerHTML = `
                <div id="phenomena-circle">
                    <div id="audio-indicator"></div>
                </div>
                <div id="loud-label" class="phenomenon-label">LAUT</div>
                <div id="quiet-label" class="phenomenon-label">LEISE</div>
                <div id="scattered-label" class="phenomenon-label">ABWECHSELND</div>
                <div id="sorted-label" class="phenomenon-label">GLEICH</div>
            `;
            
            // NEU: Standard-Position anzeigen
            updateAudioIndicator(null);
        }

        // NEUE FUNKTION: Audio-Indikator aktualisieren
        function updateAudioIndicator(audioData) {
            const indicator = document.getElementById('audio-indicator');
            if (!indicator) return;
            
            if (!audioData) {
                // NEU: Standard-Position (Mitte)
                indicator.style.left = '50%';
                indicator.style.top = '50%';
                indicator.style.background = '#00ff00';
                return;
            }
            
            // NEU: Position basierend auf Audio-Daten berechnen
            const loudness = audioData.averageDb || 0.5;
            const variation = audioData.dbVariation || 0.5;
            
            // NEU: X-Position (Laut/Leise) - links = leise, rechts = laut
            const xPos = 20 + (loudness * 60); // 20% - 80%
            
            // NEU: Y-Position (Abwechselnd/Gleich) - oben = abwechselnd, unten = gleich
            const yPos = 20 + ((1 - variation) * 60); // 20% - 80%
            
            indicator.style.left = xPos + '%';
            indicator.style.top = yPos + '%';
            
            // NEU: Farbe basierend auf Intensit√§t
            const intensity = Math.max(loudness, variation);
            const green = Math.round(255 * (1 - intensity));
            const red = Math.round(255 * intensity);
            indicator.style.background = `rgb(${red}, ${green}, 0)`;
            
            console.log(` Audio-Indikator: X=${xPos.toFixed(1)}%, Y=${yPos.toFixed(1)}%, Intensit√§t=${intensity.toFixed(2)}`);
        }

        // NEUE FUNKTION: Audio-Visualisierung zur√ºcksetzen (IMMER ANZEIGEN)
        function resetAudioVisualization() {
            // NEU: Zeige Standard-Position anstatt zu verstecken
            updateAudioIndicator(null);
        }

        // NEUE FUNKTION: Detailfenster √∂ffnen
        function openAudioDetailWindow() {
            // NEU: Detailfenster erstellen falls nicht vorhanden
            let detailWindow = document.getElementById('audio-detail-window');
            if (!detailWindow) {
                detailWindow = document.createElement('div');
                detailWindow.id = 'audio-detail-window';
                detailWindow.innerHTML = `
                    <div id="audio-detail-close">√ó</div>
                    <div id="parameter-circle">
                        <div id="large-points-label" class="parameter-label">GROSSE PUNKTE</div>
                        <div id="small-points-label" class="parameter-label">KLEINE PUNKTE</div>
                        <div id="strong-distortion-label" class="parameter-label">STARKE VERZERRUNG</div>
                        <div id="no-distortion-label" class="parameter-label">KEINE VERZERRUNG</div>
                    </div>
                `;
                document.body.appendChild(detailWindow);
                
                // NEU: Schlie√üen-Event
                const closeBtn = document.getElementById('audio-detail-close');
                closeBtn.addEventListener('click', function() {
                    detailWindow.style.display = 'none';
                });
            }
            
            detailWindow.style.display = 'block';
            initDetailWindowControls();
        }

        // NEUE FUNKTION: Detailfenster-Steuerung
        function initDetailWindowControls() {
            const parameterCircle = document.getElementById('parameter-circle');
            if (!parameterCircle) return;
            
            let isDragging = false;
            let startAngle = 0;
            let currentRotation = 0;
            
            // NEU: Touch- und Mouse-Events
            parameterCircle.addEventListener('mousedown', startRotation);
            parameterCircle.addEventListener('touchstart', startRotation);
            
            document.addEventListener('mousemove', handleRotation);
            document.addEventListener('touchmove', handleRotation);
            
            document.addEventListener('mouseup', stopRotation);
            document.addEventListener('touchend', stopRotation);
            
            function startRotation(e) {
                e.preventDefault();
                isDragging = true;
                const rect = parameterCircle.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                startAngle = Math.atan2(clientY - centerY, clientX - centerX);
            }
            
            function handleRotation(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const rect = parameterCircle.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const currentAngle = Math.atan2(clientY - centerY, clientX - centerX);
                const deltaAngle = currentAngle - startAngle;
                
                // NEU: Nur Vierteldrehungen (90¬∞ Schritte)
                const targetRotation = Math.round((currentRotation + deltaAngle) / (Math.PI / 2)) * (Math.PI / 2);
                
                if (Math.abs(targetRotation - currentRotation) > 0.1) {
                    currentRotation = targetRotation;
                    rotateParameterCircle(currentRotation);
                    updateAudioMapping(currentRotation);
                }
            }
            
            function stopRotation() {
                isDragging = false;
            }
        }

        // NEUE FUNKTION: Parameter-Kreis rotieren
        function rotateParameterCircle(angle) {
            const parameterCircle = document.getElementById('parameter-circle');
            if (parameterCircle) {
                parameterCircle.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
            }
        }

        // NEUE FUNKTION: Audio-Mapping basierend auf Rotation aktualisieren
        function updateAudioMapping(rotation) {
            const rotationDegrees = (rotation * 180) / Math.PI;
            const quarter = Math.round(rotationDegrees / 90) % 4;
            
            console.log(` Parameter-Rotation: ${rotationDegrees.toFixed(0)}¬∞ (Viertel: ${quarter})`);
            
            // NEU: Mapping basierend auf Vierteldrehung
            switch (quarter) {
                case 0: // Original
                    audioMapping = {
                        loud: 'large_points',
                        quiet: 'small_points',
                        scattered: 'strong_distortion',
                        sorted: 'no_distortion'
                    };
                    break;
                case 1: // 90¬∞ gedreht
                    audioMapping = {
                        loud: 'small_points',
                        quiet: 'large_points',
                        scattered: 'no_distortion',
                        sorted: 'strong_distortion'
                    };
                    break;
                case 2: // 180¬∞ gedreht
                    audioMapping = {
                        loud: 'small_points',
                        quiet: 'large_points',
                        scattered: 'strong_distortion',
                        sorted: 'no_distortion'
                    };
                    break;
                case 3: // 270¬∞ gedreht
                    audioMapping = {
                        loud: 'large_points',
                        quiet: 'small_points',
                        scattered: 'no_distortion',
                        sorted: 'strong_distortion'
                    };
                    break;
            }
            
            console.log("üéõÔ∏è Neues Audio-Mapping:", audioMapping);
            
            // NEU: Sofortige Anwendung auf Panoramen
            applyAudioMappingToPanoramas();
        }

        // NEUE FUNKTION: Audio-Mapping auf Panoramen anwenden
        function applyAudioMappingToPanoramas() {
            // NEU: Alle aktuellen Point Clouds mit neuen Mapping-Werten neu erstellen
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.userData.isAudioModified) {
                    recreatePointCloudWithNewMapping(child);
                }
            });
        }

        // NEUE FUNKTION: Point Cloud mit neuem Mapping neu erstellen
        function recreatePointCloudWithNewMapping(pointCloud) {
            // NEU: Point Cloud mit aktuellem Audio-Mapping neu rendern
            const audioData = pointCloud.userData.audioData;
            if (audioData) {
                // NEU: Neue Parameter basierend auf Mapping anwenden
                const newParameters = calculateAudioParameters(audioData, audioMapping);
                applyParametersToPointCloud(pointCloud, newParameters);
            }
        }

        // NEUE FUNKTION: Audio-Parameter basierend auf Mapping berechnen
        function calculateAudioParameters(audioData, mapping) {
            const loudness = audioData.averageDb || 0.5;
            const variation = audioData.dbVariation || 0.5;
            
            // NEU: Parameter basierend auf Mapping bestimmen
            let pointSize, distortionStrength;
            
            // NEU: Punktgr√∂√üe basierend auf Laut/Leise
            if (mapping.loud === 'large_points') {
                pointSize = 0.5 + (loudness * 1.5); // 0.5 - 2.0
            } else {
                pointSize = 0.5 + ((1 - loudness) * 1.5); // 0.5 - 2.0
            }
            
            // NEU: Verzerrung basierend auf Abwechselnd/Gleich
            if (mapping.scattered === 'strong_distortion') {
                distortionStrength = 0.5 + (variation * 2.0); // 0.5 - 2.5
            } else {
                distortionStrength = 0.5 + ((1 - variation) * 2.0); // 0.5 - 2.5
            }
            
            return { pointSize, distortionStrength };
        }

        // NEUE FUNKTION: Parameter auf Point Cloud anwenden
        function applyParametersToPointCloud(pointCloud, parameters) {
            // NEU: Punktgr√∂√üe anwenden
            if (pointCloud.material) {
                pointCloud.material.size = parameters.pointSize;
            }
            
            // NEU: Verzerrung anwenden (Position der Punkte ver√§ndern)
            if (pointCloud.geometry) {
                const positions = pointCloud.geometry.attributes.position;
                if (positions) {
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        const z = positions.getZ(i);
                        
                        // NEU: Verzerrung basierend auf Distortion-Strength
                        const distortion = parameters.distortionStrength;
                        const newZ = z * distortion;
                        
                        positions.setXYZ(i, x, y, newZ);
                    }
                    positions.needsUpdate = true;
                }
            }
        }

        // NEUE FUNKTION: Zeitbasierte Audio-Analyse f√ºr Depth Map-Verzerrung (NOCH SENSIBLER)
        function analyzeTimeBasedAudioData(dbLevels, recordingDuration) {
            if (!dbLevels || dbLevels.length === 0) {
                return null;
            }
            
            // Zeitbasierte DB-Level-Map erstellen
            const timeBasedDbMap = [];
            const timeStep = recordingDuration / dbLevels.length;
            
            dbLevels.forEach((entry, index) => {
                const timestamp = entry.timestamp;
                const dbLevel = entry.dbLevel;
                const normalizedTime = timestamp / recordingDuration; // 0-1
                
                timeBasedDbMap.push({
                    time: normalizedTime,
                    dbLevel: dbLevel,
                    timestamp: timestamp
                });
            });
            
            console.log("‚è∞ Zeitbasierte Audio-Analyse (SENSIBEL):");
            console.log("  Aufnahmedauer:", recordingDuration, "ms");
            console.log("  DB-Samples:", dbLevels.length);
            console.log("  Zeit-Schritte:", timeStep.toFixed(1), "ms");
            
            return timeBasedDbMap;
        }

        // NEUE FUNKTION: DB-Level f√ºr spezifische Position in der Depth Map berechnen (NOCH SENSIBLER)
        function getDbLevelForPosition(x, y, width, height, timeBasedDbMap) {
            if (!timeBasedDbMap || timeBasedDbMap.length === 0) {
                return 0.5; // Standard-Wert
            }
            
            // Position in der Depth Map zu Zeitpunkt mappen
            const normalizedX = x / width; // 0-1
            const normalizedY = y / height; // 0-1
            
            // NEU: NOCH SENSIBLERE Zeitbasierte Mapping-Strategien
            // 1. Horizontale Position (X) entspricht Zeit
            const timeIndex = Math.floor(normalizedX * timeBasedDbMap.length);
            const clampedTimeIndex = Math.max(0, Math.min(timeBasedDbMap.length - 1, timeIndex));
            
            // 2. NEU: SENSIBLERE vertikale Variation
            const verticalVariation = Math.sin(normalizedY * Math.PI * 4) * 0.2; // ¬±20% Variation (verdoppelt)
            
            // 3. Interpolation zwischen benachbarten Zeitpunkten
            let dbLevel = timeBasedDbMap[clampedTimeIndex].dbLevel;
            
            if (clampedTimeIndex < timeBasedDbMap.length - 1) {
                const nextDbLevel = timeBasedDbMap[clampedTimeIndex + 1].dbLevel;
                const interpolationFactor = (normalizedX * timeBasedDbMap.length) - clampedTimeIndex;
                dbLevel = dbLevel + (nextDbLevel - dbLevel) * interpolationFactor;
            }
            
            // NEU: SENSIBLERE vertikale Variation hinzuf√ºgen
            dbLevel += verticalVariation;
            dbLevel = Math.max(0, Math.min(1, dbLevel)); // Auf 0-1 begrenzen
            
            return dbLevel;
        }

        // NEUE FUNKTION: Dynamische Animation basierend auf Audio-Playback
        function animatePointCloudWithAudio(currentTime, timeBasedDbMap, recordingDuration) {
            if (!timeBasedDbMap || !recordingDuration) return;
            
            // Normalisierte Zeit (0-1)
            const normalizedTime = (currentTime % recordingDuration) / recordingDuration;
            
            // Finde den aktuellen DB-Level f√ºr diese Zeit
            const timeIndex = Math.floor(normalizedTime * timeBasedDbMap.length);
            const clampedTimeIndex = Math.max(0, Math.min(timeBasedDbMap.length - 1, timeIndex));
            const currentDbLevel = timeBasedDbMap[clampedTimeIndex].dbLevel;
            
            // NEU: Dynamische Animation f√ºr alle Point Clouds
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    // NEU: Bewegung basierend auf DB-Level
                    const movementIntensity = currentDbLevel * 3.0; // 0-3x Bewegung
                    
                    // NEU: Verschiedene Bewegungsarten basierend auf DB-Level
                    if (currentDbLevel > 0.7) {
                        // LAUT: Starke Rotation und Skalierung
                        child.rotation.y += 0.02 * movementIntensity;
                        child.rotation.x += 0.01 * movementIntensity;
                        
                        // Pulsierende Skalierung
                        const pulseScale = 1.0 + Math.sin(Date.now() * 0.01) * 0.2 * movementIntensity;
                        child.scale.setScalar(pulseScale);
                        
                    } else if (currentDbLevel > 0.4) {
                        // MITTEL: Moderate Rotation
                        child.rotation.y += 0.01 * movementIntensity;
                        
                        // Sanfte Skalierung
                        const gentleScale = 1.0 + Math.sin(Date.now() * 0.005) * 0.1 * movementIntensity;
                        child.scale.setScalar(gentleScale);
                        
                    } else {
                        // LEISE: Minimale Bewegung
                        child.rotation.y += 0.001 * movementIntensity;
                        child.scale.setScalar(1.0);
                    }
                    
                    // NEU: Position-Bewegung f√ºr sehr laute Bereiche
                    if (currentDbLevel > 0.8) {
                        const wobbleX = Math.sin(Date.now() * 0.02) * 0.5 * movementIntensity;
                        const wobbleY = Math.cos(Date.now() * 0.015) * 0.3 * movementIntensity;
                        child.position.x += wobbleX * 0.01;
                        child.position.y += wobbleY * 0.01;
                    }
                }
            });
            
            // Debug-Ausgabe f√ºr laute Bereiche
            if (currentDbLevel > 0.6) {
                console.log(`üéµ Audio-Animation: DB=${currentDbLevel.toFixed(2)}, Bewegung=${movementIntensity.toFixed(2)}x`);
            }
        }

        // MODIFIZIERTE FUNKTION: Panorama-Sph√§re mit NOCH SENSIBLERER Audio-Verzerrung
        async function createPanoramaSphereFromDepthMap(imageUrl, depthMapUrl, metadata) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const depthImg = new Image();
                img.crossOrigin = "anonymous";
                depthImg.crossOrigin = "anonymous";
                
                let imageLoaded = false;
                let depthLoaded = false;
                
                const checkBothLoaded = () => {
                    if (imageLoaded && depthLoaded) {
                        createSpherePointCloud();
                    }
                };
                
                img.onload = () => {
                    imageLoaded = true;
                    checkBothLoaded();
                };
                
                depthImg.onload = () => {
                    depthLoaded = true;
                    checkBothLoaded();
                };
                
                img.onerror = () => reject(new Error("Konnte Panorama-Bild nicht laden"));
                depthImg.onerror = () => reject(new Error("Konnte Depth Map nicht laden"));
                
                img.src = imageUrl;
                depthImg.src = depthMapUrl;
                
                function createSpherePointCloud() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        ctx.drawImage(depthImg, 0, 0);
                        const depthData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        const gpsCoords = metadata.gps_coordinates;
                        const gps3DPosition = geoTo3D(gpsCoords.lat, gpsCoords.lon);
                        
                        const width = canvas.width;
                        const height = canvas.height;
                        const numPoints = width * height;
                        const positions = new Float32Array(numPoints * 3);
                        const colors = new Float32Array(numPoints * 3);
                        
                        // NEU: Zeitbasierte Audio-Analyse
                        let timeBasedDbMap = null;
                        let recordingDuration = 0;
                        
                        if (dbLevels && dbLevels.length > 0) {
                            // Aufnahmedauer berechnen
                            const firstTimestamp = dbLevels[0].timestamp;
                            const lastTimestamp = dbLevels[dbLevels.length - 1].timestamp;
                            recordingDuration = lastTimestamp - firstTimestamp;
                            
                            timeBasedDbMap = analyzeTimeBasedAudioData(dbLevels, recordingDuration);
                            console.log("‚è∞ Zeitbasierte DB-Map erstellt:", timeBasedDbMap.length, "Eintr√§ge");
                            
                            // Audio-Visualisierung aktualisieren
                            const audioAnalysis = analyzeAudioData(dbLevels);
                            updateAudioVisualization(audioAnalysis);
                        }
                        
                        // NEU: Audio-basierte Modifikationen (NOCH SENSIBLER)
                        let baseRadius = 25.0;
                        let baseDepthInfluence = 8.0;
                        let pointSizeMultiplier = 1.0;
                        
                        // Bestehende Stitching-Statistiken
                        if (metadata.stitching_stats) {
                            const successfulFrames = metadata.stitching_stats.successful_frames;
                            const frameSteps = Math.floor(successfulFrames / 5);
                            baseRadius = Math.max(10.0, Math.min(50.0, 10.0 + (frameSteps * 5)));
                            baseDepthInfluence = Math.max(4.0, Math.min(16.0, 4.0 + (frameSteps * 2)));
                            
                            console.log(` Stitching + Audio: Radius=${baseRadius.toFixed(1)}, BaseDepth=${baseDepthInfluence.toFixed(1)}`);
                        }
                        
                        let pointIndex = 0;
                        const progressInterval = Math.max(1, Math.floor(numPoints / 10));
                        
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const pixelIndex = (y * width + x) * 4;
                                
                                const u = (x / width) * 2 * Math.PI;
                                const v = (y / height) * Math.PI;
                                
                                const r = imageData.data[pixelIndex] / 255;
                                const g = imageData.data[pixelIndex + 1] / 255;
                                const b = imageData.data[pixelIndex + 2] / 255;
                                
                                const originalDepth = depthData.data[pixelIndex] / 255;
                                
                                // NEU: NOCH SENSIBLERE zeitbasierte DB-Level f√ºr diese Position
                                let dbLevel = 0.5; // Standard-Wert
                                let depthInfluence = baseDepthInfluence;
                                
                                if (timeBasedDbMap) {
                                    dbLevel = getDbLevelForPosition(x, y, width, height, timeBasedDbMap);
                                    
                                    // NEU: NOCH SENSIBLERE dynamische Depth-Influence
                                    // Laut = viel mehr Verzerrung, Leise = viel weniger Verzerrung
                                    const dbMultiplier = 0.1 + (dbLevel * 4.9); // 0.1-5.0 statt 0.3-3.0
                                    depthInfluence = baseDepthInfluence * dbMultiplier;
                                    
                                    // Debug f√ºr erste paar Punkte
                                    if (pointIndex < 10) {
                                        console.log(` Punkt ${pointIndex}: X=${x}, Y=${y}, DB=${dbLevel.toFixed(3)}, DepthMult=${dbMultiplier.toFixed(2)}`);
                                    }
                                }
                                
                                // NEU: NOCH SENSIBLERE verzerrte Depth basierend auf DB-Level
                                const distortedDepth = originalDepth * (1 + (dbLevel - 0.5) * 4); // -2 bis +2 Verzerrung statt -1 bis +1
                                const clampedDepth = Math.max(0, Math.min(1, distortedDepth));
                                
                                const depthRadius = baseRadius + (clampedDepth * depthInfluence);
                                
                                const sphereX = depthRadius * Math.sin(v) * Math.cos(u);
                                const sphereY = depthRadius * Math.cos(v);
                                const sphereZ = depthRadius * Math.sin(v) * Math.sin(u);
                                
                                positions[pointIndex * 3] = gps3DPosition.x + sphereX;
                                positions[pointIndex * 3 + 1] = gps3DPosition.y + sphereY;
                                positions[pointIndex * 3 + 2] = gps3DPosition.z + sphereZ;
                                
                                colors[pointIndex * 3] = r;
                                colors[pointIndex * 3 + 1] = g;
                                colors[pointIndex * 3 + 2] = b;
                                
                                pointIndex++;
                                
                                if (pointIndex % progressInterval === 0) {
                                    const progress = Math.round((pointIndex / numPoints) * 100);
                                    showStatus(`Sph√§re-Generierung: ${progress}%`, 'processing');
                                }
                            }
                        }
                        
                        const pointCloudData = {
                            positions: positions,
                            colors: colors,
                            count: numPoints,
                            metadata: {
                                ...metadata,
                                type: 'panorama_sphere',
                                baseRadius: baseRadius,
                                baseDepthInfluence: baseDepthInfluence,
                                gps3DPosition: gps3DPosition,
                                timeBasedDbMap: timeBasedDbMap, // NEU: Zeitbasierte DB-Map
                                recordingDuration: recordingDuration, // NEU: Aufnahmedauer
                                pointSizeMultiplier: pointSizeMultiplier
                            }
                        };
                        
                        // NEU: Audio-Modifikationen f√ºr aktuelle Point Cloud speichern
                        currentPanoramaAudioModifications = {
                            pointSizeMultiplier: pointSizeMultiplier,
                            timeBasedDbMap: timeBasedDbMap,
                            recordingDuration: recordingDuration
                        };
                        
                        createPointCloudInScene(pointCloudData, { x: 0, y: 0, z: 0 });
                        
                        loadedPanoramas.push({
                            metadata: metadata,
                            pointCloudData: pointCloudData,
                            imageUrl: imageUrl,
                            depthMapUrl: depthMapUrl,
                            type: 'sphere',
                            timeBasedDbMap: timeBasedDbMap // NEU: Zeitbasierte DB-Map
                        });
                        
                        console.log("‚úÖ 360¬∞ Panorama-Sph√§re mit SENSIBLERER Audio-Verzerrung erstellt");
                        console.log(" Sph√§re-Position:", gps3DPosition);
                        console.log("üîµ Sph√§re-Radius:", baseRadius);
                        if (timeBasedDbMap) {
                            console.log("‚è∞ SENSIBLERE zeitbasierte Audio-Verzerrung angewendet");
                        }
                        resolve();
                        
                    } catch (error) {
                        reject(error);
                    }
                }
            });
        }

        // MODIFIZIERTE FUNKTION: Audio abspielen mit dynamischer Animation
        function playRecordedAudio() {
            if (!recordedAudioBlob || !dbLevels.length) {
                showStatus("Kein Audio oder DB-Daten verf√ºgbar", "error");
                return;
            }
            
            try {
                if (isPlayingAudio) {
                    stopAudioPlayback();
                    return;
                }
                
                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                audioPlayer = new Audio(audioUrl);
                
                // NEU: Audio-Eigenschaften f√ºr mobile Kompatibilit√§t
                audioPlayer.preload = 'auto';
                audioPlayer.volume = 1.0;
                audioPlayer.muted = false;
                
                // NEU: Audio-Context f√ºr Echtzeit-Analyse
                currentAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioAnalyser = currentAudioContext.createAnalyser();
                audioSource = currentAudioContext.createMediaElementSource(audioPlayer);
                
                // NEU: Verbindungen herstellen
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(currentAudioContext.destination);
                
                audioAnalyser.fftSize = 256;
                
                let playbackStartTime = Date.now();
                let currentDbIndex = 0;
                
                // NEU: Zeitbasierte DB-Map f√ºr Animation
                const recordingDuration = dbLevels[dbLevels.length - 1].timestamp - dbLevels[0].timestamp;
                const timeBasedDbMap = analyzeTimeBasedAudioData(dbLevels, recordingDuration);
                
                // NEU: Audio-Event-Listener f√ºr bessere Kontrolle
                audioPlayer.addEventListener('canplaythrough', () => {
                    console.log("‚úÖ Audio bereit zum Abspielen");
                });
                
                audioPlayer.addEventListener('error', (error) => {
                    console.error("‚ùå Audio-Fehler:", error);
                    // NEU: Keine Status-Anzeige bei Audio-Fehlern
                });
                
                audioPlaybackInterval = setInterval(() => {
                    const currentTime = Date.now() - playbackStartTime;
                    
                    // NEU: Dynamische Animation basierend auf aktueller Zeit
                    animatePointCloudWithAudio(currentTime, timeBasedDbMap, recordingDuration);
                    
                    // Finde den passenden DB-Level f√ºr die aktuelle Zeit
                    while (currentDbIndex < dbLevels.length && 
                           dbLevels[currentDbIndex].timestamp < currentTime) {
                        currentDbIndex++;
                    }
                    
                    if (currentDbIndex < dbLevels.length) {
                        const currentDb = dbLevels[currentDbIndex].dbLevel;
                        
                        // NEU: Erweiterte Audio-Animation
                        if (currentDb > 0.6) {
                            console.log(` Audio Playback: DB=${currentDb.toFixed(3)}, Zeit=${(currentTime/1000).toFixed(1)}s`);
                        }
                    }
                }, 50);
                
                audioPlayer.addEventListener('ended', () => {
                    stopAudioPlayback();
                    showStatus("Audio-Wiedergabe beendet", "info");
                });
                
                // NEU: Audio direkt abspielen - KEINE BERECHTIGUNGSANFRAGE
                audioPlayer.play().then(() => {
                    isPlayingAudio = true;
                    showStatus("Audio wird abgespielt...", "success");
                    console.log("‚úÖ Audio erfolgreich gestartet");
                }).catch(playError => {
                    console.error("‚ùå Audio-Play fehlgeschlagen:", playError);
                    
                    // NEU: KEINE Fallback-Mechanismen - einfach ignorieren
                    console.log("‚ö†Ô∏è Audio-Autoplay blockiert - ignoriere");
                    
                    // NEU: Trotzdem Animation starten (ohne Audio)
                    if (timeBasedDbMap) {
                        console.log("üéµ Starte Animation ohne Audio...");
                        startAnimationWithoutAudio(timeBasedDbMap, recordingDuration);
                    }
                });
                
            } catch (error) {
                console.error("Audio-Wiedergabe Fehler:", error);
                // NEU: Keine Status-Anzeige bei Fehlern
            }
        }

        // NEUE FUNKTION: Animation ohne Audio
        function startAnimationWithoutAudio(timeBasedDbMap, recordingDuration) {
            console.log("üé¨ Starte Animation ohne Audio-Playback");
            
            let animationStartTime = Date.now();
            let currentDbIndex = 0;
            
            // NEU: Animation-Interval ohne Audio
            const animationInterval = setInterval(() => {
                const currentTime = Date.now() - animationStartTime;
                
                // NEU: Dynamische Animation basierend auf aktueller Zeit
                animatePointCloudWithAudio(currentTime, timeBasedDbMap, recordingDuration);
                
                // Finde den passenden DB-Level f√ºr die aktuelle Zeit
                while (currentDbIndex < dbLevels.length && 
                       dbLevels[currentDbIndex].timestamp < currentTime) {
                    currentDbIndex++;
                }
                
                if (currentDbIndex < dbLevels.length) {
                    const currentDb = dbLevels[currentDbIndex].dbLevel;
                    
                    if (currentDb > 0.6) {
                        console.log(`üé¨ Animation: DB=${currentDb.toFixed(3)}, Zeit=${(currentTime/1000).toFixed(1)}s`);
                    }
                }
                
                // NEU: Animation stoppen nach Aufnahmedauer
                if (currentTime >= recordingDuration) {
                    clearInterval(animationInterval);
                    console.log("üé¨ Animation beendet");
                    showStatus("Animation beendet", "info");
                }
            }, 50);
            
            // NEU: Animation-Interval speichern f√ºr sp√§teres Stoppen
            window.animationInterval = animationInterval;
        }

        // MODIFIZIERTE FUNKTION: Audio-Wiedergabe stoppen (erweitert f√ºr Animation)
        function stopAudioPlayback() {
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer = null;
            }
            
            if (audioPlaybackInterval) {
                clearInterval(audioPlaybackInterval);
                audioPlaybackInterval = null;
            }
            
            // NEU: Auch Animation-Interval stoppen
            if (window.animationInterval) {
                clearInterval(window.animationInterval);
                window.animationInterval = null;
            }
            
            if (currentAudioContext) {
                currentAudioContext.close();
                currentAudioContext = null;
            }
            
            // NEU: Point Clouds zur√ºcksetzen
            scene.children.forEach(child => {
                if (child.type === 'Points') {
                    child.rotation.set(0, 0, 0);
                    child.scale.setScalar(1.0);
                    child.position.set(0, 0, 0);
                }
            });
            
            isPlayingAudio = false;
            console.log("Audio-Wiedergabe und Animation gestoppt");
        }

        // MODIFIZIERTE FUNKTION: Audio-Context sicher erstellen (vereinfacht)
        function createSafeAudioContext() {
            try {
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContextClass();
                
                // NEU: Resume Audio-Context falls suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("‚úÖ Audio-Context erfolgreich resumed");
                    }).catch(error => {
                        console.error("‚ùå Audio-Context resume fehlgeschlagen:", error);
                    });
                }
                
                return audioContext;
            } catch (error) {
                console.error("‚ùå Audio-Context Erstellung fehlgeschlagen:", error);
                return null;
            }
        }

        // MODIFIZIERTE FUNKTION: Mobile Audio-Initialisierung (vereinfacht)
        async function initMobileAudio() {
            console.log("üì± Initialisiere Mobile Audio...");
            
            // NEU: Pr√ºfe ob es ein mobiles Ger√§t ist
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log("üì± Ist mobiles Ger√§t:", isMobile);
            
            if (isMobile) {
                // NEU: Mobile-spezifische Audio-Einstellungen
                console.log("üì± Verwende mobile Audio-Einstellungen");
                
                // NEU: Audio-Context mit mobile-spezifischen Optionen
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                if (AudioContextClass) {
                    try {
                        // NEU: Audio-Context mit mobile-optimierten Einstellungen
                        currentAudioContext = new AudioContextClass({
                            latencyHint: 'interactive',
                            sampleRate: 44100
                        });
                        
                        console.log("‚úÖ Mobile Audio-Context erstellt");
                        
                    } catch (error) {
                        console.error("‚ùå Mobile Audio-Context Erstellung fehlgeschlagen:", error);
                    }
                }
            }
        }

        // NEUE FUNKTION: Audio-Test f√ºr mobile Ger√§te
        function testMobileAudio() {
            console.log(" Teste mobile Audio-Kompatibilit√§t...");
            console.log("User Agent:", navigator.userAgent);
            console.log("Audio-Context verf√ºgbar:", !!(window.AudioContext || window.webkitAudioContext));
            console.log("MediaDevices verf√ºgbar:", !!navigator.mediaDevices);
            
            // NEU: Pr√ºfe Audio-Autoplay-Policy
            const audio = new Audio();
            audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';
            audio.volume = 0;
            
            audio.play().then(() => {
                console.log("‚úÖ Audio-Autoplay funktioniert");
            }).catch(error => {
                console.log("‚ö†Ô∏è Audio-Autoplay blockiert:", error.name);
            });
        }

        // NEUE FUNKTION: Audio-Status anzeigen
        function showAudioStatus() {
            const statusDiv = document.createElement('div');
            statusDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 20px;
                border-radius: 10px;
                z-index: 10000;
                text-align: center;
                font-size: 16px;
            `;
            
            statusDiv.innerHTML = `
                <h3>Audio-Status</h3>
                <p>Audio-Context: ${currentAudioContext ? currentAudioContext.state : 'Nicht erstellt'}</p>
                <p>Audio-Player: ${audioPlayer ? 'Erstellt' : 'Nicht erstellt'}</p>
                <p>Ist Abspielend: ${isPlayingAudio ? 'Ja' : 'Nein'}</p>
                <p>DB-Levels: ${dbLevels ? dbLevels.length : 0}</p>
                <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px;">Schlie√üen</button>
            `;
            
            document.body.appendChild(statusDiv);
        }

        // NEUE FUNKTION: Audio-Problem beheben
        function fixAudioIssues() {
            console.log("üîß Behebe Audio-Probleme...");
            
            // NEU: Audio-Context zur√ºcksetzen
            if (currentAudioContext) {
                currentAudioContext.close();
                currentAudioContext = null;
            }
            
            // NEU: Audio-Player zur√ºcksetzen
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer = null;
            }
            
            // NEU: Interval zur√ºcksetzen
            if (audioPlaybackInterval) {
                clearInterval(audioPlaybackInterval);
                audioPlaybackInterval = null;
            }
            
            isPlayingAudio = false;
            
            showStatus("Audio-System zur√ºckgesetzt. Versuche es nochmal.", "info");
        }

        // MODIFIZIERTE FUNKTION: Event Listeners f√ºr neue Buttons
        document.getElementById('play-audio-btn').addEventListener('click', playRecordedAudio);

        // NEUE BUTTONS f√ºr Audio-Debugging (optional)
        // F√ºge diese Buttons zur UI hinzu f√ºr Debugging:
        /*
        <button class="btn" onclick="testMobileAudio()">AUDIO TEST</button>
        <button class="btn" onclick="showAudioStatus()">AUDIO STATUS</button>
        <button class="btn" onclick="fixAudioIssues()">AUDIO RESET</button>
        */

        // NEU: Audio-Test beim Laden
        document.addEventListener('DOMContentLoaded', function() {
            // ... bestehender Code ...
            
            // Audio-Test f√ºr mobile Ger√§te
            testMobileAudio();
        });

        // NEUE FUNKTION: Browser-Berechtigungen pr√ºfen und anfordern
        async function checkAndRequestAudioPermissions() {
            console.log("üîê Pr√ºfe Audio-Berechtigungen...");
            
            try {
                // NEU: Pr√ºfe ob Audio-Context verf√ºgbar ist
                if (!(window.AudioContext || window.webkitAudioContext)) {
                    throw new Error("Audio-Context wird von diesem Browser nicht unterst√ºtzt");
                }
                
                // NEU: Pr√ºfe MediaDevices-Berechtigung
                if (!navigator.mediaDevices) {
                    throw new Error("MediaDevices werden von diesem Browser nicht unterst√ºtzt");
                }
                
                // NEU: Pr√ºfe Audio-Autoplay-Policy
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';
                audio.volume = 0;
                
                try {
                    await audio.play();
                    console.log("‚úÖ Audio-Autoplay funktioniert");
                } catch (autoplayError) {
                    console.log("‚ö†Ô∏è Audio-Autoplay blockiert:", autoplayError.name);
                    showStatus("Audio-Autoplay blockiert. Tippe auf den Bildschirm zum Starten.", "info");
                }
                
                return true;
                
            } catch (error) {
                console.error("‚ùå Audio-Berechtigungsfehler:", error);
                showStatus(`Audio-Berechtigung: ${error.message}`, "error");
                return false;
            }
        }

        // NEUE FUNKTION: Mobile-spezifische Audio-Initialisierung
        async function initMobileAudio() {
            console.log("üì± Initialisiere Mobile Audio...");
            
            // NEU: Pr√ºfe ob es ein mobiles Ger√§t ist
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log("üì± Ist mobiles Ger√§t:", isMobile);
            
            if (isMobile) {
                // NEU: Mobile-spezifische Audio-Einstellungen
                console.log("üì± Verwende mobile Audio-Einstellungen");
                
                // NEU: Audio-Context mit mobile-spezifischen Optionen
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                if (AudioContextClass) {
                    try {
                        // NEU: Audio-Context mit mobile-optimierten Einstellungen
                        currentAudioContext = new AudioContextClass({
                            latencyHint: 'interactive',
                            sampleRate: 44100
                        });
                        
                        console.log("‚úÖ Mobile Audio-Context erstellt");
                        
                    } catch (error) {
                        console.error("‚ùå Mobile Audio-Context Erstellung fehlgeschlagen:", error);
                    }
                }
            }
        }

        // NEUE FUNKTION: Audio mit expliziter User-Interaction starten
        async function startAudioWithExplicitPermission() {
            console.log("üéµ Starte Audio mit expliziter Berechtigung...");
            
            // NEU: Zeige Berechtigungsanfrage
            const permissionDialog = document.createElement('div');
            permissionDialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            permissionDialog.innerHTML = `
                <div style="background: rgba(0, 0, 0, 0.8); color: white; padding: 30px; border-radius: 15px; text-align: center; max-width: 300px;">
                    <h3> Audio-Berechtigung</h3>
                    <p>Um den Sound abzuspielen, m√ºssen Sie die Audio-Berechtigung erlauben.</p>
                    <p style="font-size: 12px; margin-top: 10px;">Tippen Sie auf "Audio starten" um fortzufahren.</p>
                    <button id="start-audio-btn" style="
                        background: #4CAF50;
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        margin-top: 20px;
                        cursor: pointer;
                    ">AUDIO STARTEN</button>
                    <button id="cancel-audio-btn" style="
                        background: #f44336;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 8px;
                        font-size: 14px;
                        margin-top: 10px;
                        cursor: pointer;
                    ">ABBRECHEN</button>
                </div>
            `;
            
            document.body.appendChild(permissionDialog);
            
            // NEU: Event-Listener f√ºr Buttons
            document.getElementById('start-audio-btn').addEventListener('click', async () => {
                try {
                    // NEU: Audio-Context sicherstellen
                    if (!currentAudioContext || currentAudioContext.state === 'suspended') {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        currentAudioContext = new AudioContextClass();
                        await currentAudioContext.resume();
                    }
                    
                    // NEU: Audio-Playback starten
                    await playRecordedAudioWithContext(currentAudioContext);
                    
                    // NEU: Dialog schlie√üen
                    permissionDialog.remove();
                    
                } catch (error) {
                    console.error("‚ùå Audio-Start fehlgeschlagen:", error);
                    showStatus(`Audio-Start Fehler: ${error.message}`, "error");
                    permissionDialog.remove();
                }
            });
            
            document.getElementById('cancel-audio-btn').addEventListener('click', () => {
                permissionDialog.remove();
                showStatus("Audio-Start abgebrochen", "info");
            });
        }

        // MODIFIZIERTE FUNKTION: Audio abspielen (mit expliziter Berechtigung)
        function playRecordedAudio() {
            // NEU: Pr√ºfe Berechtigungen und starte mit expliziter User-Interaction
            checkAndRequestAudioPermissions().then(hasPermissions => {
                if (hasPermissions) {
                    startAudioWithExplicitPermission();
                } else {
                    showStatus("Audio-Berechtigungen nicht verf√ºgbar", "error");
                }
            });
        }

        // NEUE FUNKTION: Browser-spezifische Audio-Fixes
        function applyBrowserSpecificAudioFixes() {
            const userAgent = navigator.userAgent;
            console.log("üåê Browser:", userAgent);
            
            // NEU: Safari-spezifische Fixes
            if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                console.log(" Safari-spezifische Audio-Fixes anwenden...");
                
                // NEU: Safari ben√∂tigt oft explizite User-Interaction
                const safariAudioFix = () => {
                    if (currentAudioContext && currentAudioContext.state === 'suspended') {
                        currentAudioContext.resume();
                    }
                };
                
                document.addEventListener('touchstart', safariAudioFix, { once: true });
                document.addEventListener('click', safariAudioFix, { once: true });
            }
            
            // NEU: Chrome Mobile-spezifische Fixes
            if (userAgent.includes('Chrome') && /Android|iPhone|iPad/i.test(userAgent)) {
                console.log(" Chrome Mobile-spezifische Audio-Fixes anwenden...");
                
                // NEU: Chrome Mobile ben√∂tigt oft mehrere User-Interactions
                let interactionCount = 0;
                const chromeMobileFix = () => {
                    interactionCount++;
                    if (currentAudioContext && currentAudioContext.state === 'suspended') {
                        currentAudioContext.resume();
                    }
                    if (interactionCount >= 2) {
                        document.removeEventListener('touchstart', chromeMobileFix);
                        document.removeEventListener('click', chromeMobileFix);
                    }
                };
                
                document.addEventListener('touchstart', chromeMobileFix);
                document.addEventListener('click', chromeMobileFix);
            }
        }

        // NEUE FUNKTION: Audio-Status-Diagnose
        function diagnoseAudioIssues() {
            const diagnosis = {
                userAgent: navigator.userAgent,
                isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                audioContextSupported: !!(window.AudioContext || window.webkitAudioContext),
                mediaDevicesSupported: !!navigator.mediaDevices,
                audioContextState: currentAudioContext ? currentAudioContext.state : 'Nicht erstellt',
                audioPlayerExists: !!audioPlayer,
                isPlaying: isPlayingAudio,
                dbLevelsCount: dbLevels ? dbLevels.length : 0,
                recordedAudioExists: !!recordedAudioBlob
            };
            
            console.log("üîç Audio-Diagnose:", diagnosis);
            
            // NEU: Zeige Diagnose in UI
            const diagnosisDialog = document.createElement('div');
            diagnosisDialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 20px;
                border-radius: 10px;
                z-index: 10000;
                max-width: 400px;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            diagnosisDialog.innerHTML = `
                <h3> Audio-Diagnose</h3>
                <div style="font-size: 12px; line-height: 1.4;">
                    <p><strong>Mobil:</strong> ${diagnosis.isMobile ? 'Ja' : 'Nein'}</p>
                    <p><strong>Audio-Context:</strong> ${diagnosis.audioContextSupported ? 'Unterst√ºtzt' : 'Nicht unterst√ºtzt'}</p>
                    <p><strong>Audio-Context Status:</strong> ${diagnosis.audioContextState}</p>
                    <p><strong>MediaDevices:</strong> ${diagnosis.mediaDevicesSupported ? 'Unterst√ºtzt' : 'Nicht unterst√ºtzt'}</p>
                    <p><strong>Audio-Player:</strong> ${diagnosis.audioPlayerExists ? 'Erstellt' : 'Nicht erstellt'}</p>
                    <p><strong>Spielt ab:</strong> ${diagnosis.isPlaying ? 'Ja' : 'Nein'}</p>
                    <p><strong>DB-Levels:</strong> ${diagnosis.dbLevelsCount}</p>
                    <p><strong>Audio-Blob:</strong> ${diagnosis.recordedAudioExists ? 'Vorhanden' : 'Nicht vorhanden'}</p>
                </div>
                <button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px;">Schlie√üen</button>
            `;
            
            document.body.appendChild(diagnosisDialog);
        }

        // NEUE BUTTONS f√ºr Audio-Debugging (optional - f√ºge sie zur UI hinzu)
        // <button class="btn" onclick="diagnoseAudioIssues()">AUDIO DIAGNOSE</button>
        // <button class="btn" onclick="applyBrowserSpecificAudioFixes()">AUDIO FIX</button>

        // NEU: Initialisierung beim Laden
        document.addEventListener('DOMContentLoaded', function() {
            // ... bestehender Code ...
            
            // NEU: Mobile Audio initialisieren (vereinfacht)
            initMobileAudio();
            
            // NEU: Browser-spezifische Fixes anwenden
            applyBrowserSpecificAudioFixes();
            
            // NEU: Audio-Berechtigungen pr√ºfen
            checkAndRequestAudioPermissions();
        });

        // NEUE GLOBALE VARIABLEN f√ºr erweiterte Audio-Visualisierung
        let detailWindowOpen = false;
        let rotationAngle = 0;
        let customAudioModifications = {
            pointSizeMultiplier: 1.0,
            depthInfluenceMultiplier: 1.0,
            consistencyMultiplier: 1.0,
            volumeMultiplier: 1.0
        };

        // NEU: 8 Begriffe f√ºr die Rotation
        const rotationTerms = [
            "KLEINE PUNKTE",
            "GROSSE PUNKTE", 
            "SORTED",
            "SCATTERED",
            "FLACHE DEPTH",
            "STARKE DEPTH",
            "GLEICH",
            "ABWECHSELND"
        ];

        // NEUE FUNKTION: Labels basierend auf Rotation aktualisieren
        function updateRotationLabels(angle) {
            const labels = document.querySelectorAll('.detail-labels');
            const steps = Math.floor(angle / 90); // 0, 1, 2, 3
            
            labels.forEach((label, index) => {
                // NEU: Berechne neue Position basierend auf Rotation
                const newIndex = (index + steps) % 8;
                const newText = rotationTerms[newIndex];
                
                // NEU: Text aktualisieren
                label.textContent = newText;
                label.setAttribute('data-original-text', newText);
                
                // NEU: Farbe basierend auf Position anpassen
                if (newIndex < 4) {
                    // Erste 4 Begriffe: Gr√ºn-T√∂ne
                    label.style.color = `hsl(${120 + newIndex * 30}, 80%, 70%)`;
                } else {
                    // Letzte 4 Begriffe: Rot-T√∂ne
                    label.style.color = `hsl(${0 + (newIndex - 4) * 30}, 80%, 70%)`;
                }
            });
        }

        // NEUE FUNKTION: Rotation anwenden (nur Viertelschritte)
        function applyRotation(angle) {
            // NEU: Nur Vierteldrehungen erlauben
            const validAngles = [0, 90, 180, 270];
            const closestAngle = validAngles.reduce((prev, curr) => {
                return Math.abs(curr - angle) < Math.abs(prev - angle) ? curr : prev;
            });
            
            rotationAngle = closestAngle;
            
            // NEU: Slider auf g√ºltigen Wert setzen
            const slider = document.getElementById('rotation-slider');
            if (slider) {
                slider.value = closestAngle;
            }
            
            // NEU: Button-Status aktualisieren
            updateRotationButtons(closestAngle);
            
            // NEU: Labels aktualisieren
            updateRotationLabels(closestAngle);
            
            // NEU: Berechne neue Modifikationen basierend auf Rotation
            const quarterSteps = closestAngle / 90; // 0, 1, 2, 3
            
            // NEU: Modifikationen f√ºr jede Vierteldrehung
            switch (quarterSteps) {
                case 0: // 0¬∞ - Standard
                    customAudioModifications = {
                        pointSizeMultiplier: 0.5, // Kleine Punkte
                        depthInfluenceMultiplier: 0.3, // Flache Depth
                        consistencyMultiplier: 0.5, // Gleich
                        volumeMultiplier: 0.5 // Leise
                    };
                    break;
                    
                case 1: // 90¬∞ - Erste Vierteldrehung
                    customAudioModifications = {
                        pointSizeMultiplier: 2.0, // Gro√üe Punkte
                        depthInfluenceMultiplier: 0.3, // Flache Depth
                        consistencyMultiplier: 0.5, // Gleich
                        volumeMultiplier: 0.5 // Leise
                    };
                    break;
                    
                case 2: // 180¬∞ - Zweite Vierteldrehung
                    customAudioModifications = {
                        pointSizeMultiplier: 2.0, // Gro√üe Punkte
                        depthInfluenceMultiplier: 3.0, // Starke Depth
                        consistencyMultiplier: 0.5, // Gleich
                        volumeMultiplier: 0.5 // Leise
                    };
                    break;
                    
                case 3: // 270¬∞ - Dritte Vierteldrehung
                    customAudioModifications = {
                        pointSizeMultiplier: 2.0, // Gro√üe Punkte
                        depthInfluenceMultiplier: 3.0, // Starke Depth
                        consistencyMultiplier: 2.0, // Abwechselnd
                        volumeMultiplier: 0.5 // Leise
                    };
                    break;
            }
            
            // NEU: Detailfenster aktualisieren
            updateDetailWindow();
            
            // NEU: Aktuelle Point Clouds mit neuen Modifikationen aktualisieren
            applyCustomAudioModifications();
            
            console.log(`üîÑ Rotation angewendet: ${closestAngle}¬∞ (${quarterSteps} Viertelschritte)`);
            console.log("üéõÔ∏è  Neue Modifikationen:", customAudioModifications);
        }

        // NEUE FUNKTION: Rotation-Buttons aktualisieren
        function updateRotationButtons(activeAngle) {
            const buttons = document.querySelectorAll('.rotation-step-btn');
            buttons.forEach(button => {
                const buttonAngle = parseInt(button.getAttribute('data-angle'));
                if (buttonAngle === activeAngle) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // NEUE FUNKTION: Detailfenster aktualisieren
        function updateDetailWindow() {
            if (!detailWindowOpen) return;
            
            const detailIndicator = document.getElementById('detail-indicator');
            const rotationValue = document.getElementById('rotation-value');
            
            if (!detailIndicator || !rotationValue) return;
            
            // NEU: Position basierend auf aktuellen Audio-Werten
            const x = customAudioModifications.volumeMultiplier; // 0-1
            const y = customAudioModifications.consistencyMultiplier; // 0-1
            
            // NEU: Position im Kreis berechnen (0-1 zu -1 bis 1)
            const circleX = (x - 0.5) * 2; // -1 bis 1
            const circleY = (y - 0.5) * 2; // -1 bis 1
            
            // NEU: Auf Kreis begrenzen
            const distance = Math.sqrt(circleX * circleX + circleY * circleY);
            const clampedX = distance > 1 ? circleX / distance : circleX;
            const clampedY = distance > 1 ? circleY / distance : circleY;
            
            // NEU: Position in Pixeln (innerer Kreis = 100px Radius)
            const pixelX = clampedX * 100;
            const pixelY = clampedY * 100;
            
            // NEU: Farbe basierend auf Position
            const hue = x * 120; // Gr√ºn (kleine Punkte) -> Rot (gro√üe Punkte)
            const saturation = 80 + (y * 20); // 80-100%
            const lightness = 50 + (y * 20); // 50-70%
            
            detailIndicator.style.transform = `translate(calc(-50% + ${pixelX}px), calc(-50% + ${pixelY}px))`;
            detailIndicator.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // NEU: Rotation anzeigen
            rotationValue.textContent = `${rotationAngle}¬∞`;
            
            console.log(`üéØ Detail-Window: X=${x.toFixed(2)}, Y=${y.toFixed(2)}, Rotation=${rotationAngle}¬∞`);
        }

        // NEUE FUNKTION: Event-Listener f√ºr Detailfenster (erweitert)
        function setupDetailWindowEvents() {
            // NEU: Click-Event f√ºr Audio-Visualisierung
            const visualization = document.getElementById('audio-visualization');
            if (visualization) {
                visualization.addEventListener('click', openAudioDetailWindow);
            }
            
            // NEU: Close-Button f√ºr Detailfenster
            const closeBtn = document.getElementById('detail-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeAudioDetailWindow);
            }
            
            // NEU: Rotation-Slider (nur Viertelschritte)
            const rotationSlider = document.getElementById('rotation-slider');
            if (rotationSlider) {
                rotationSlider.addEventListener('input', (e) => {
                    const angle = parseInt(e.target.value);
                    applyRotation(angle);
                });
            }
            
            // NEU: Rotation-Buttons
            const rotationButtons = document.querySelectorAll('.rotation-step-btn');
            rotationButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const angle = parseInt(button.getAttribute('data-angle'));
                    applyRotation(angle);
                });
            });
            
            // NEU: Click au√üerhalb schlie√üt Detailfenster
            document.addEventListener('click', (e) => {
                const detailWindow = document.getElementById('audio-detail-window');
                const visualization = document.getElementById('audio-visualization');
                
                if (detailWindowOpen && 
                    !detailWindow.contains(e.target) && 
                    !visualization.contains(e.target)) {
                    closeAudioDetailWindow();
                }
            });
        }

        // NEUE FUNKTION: Detailfenster √∂ffnen (erweitert)
        function openAudioDetailWindow() {
            const detailWindow = document.getElementById('audio-detail-window');
            if (detailWindow) {
                detailWindow.style.display = 'block';
                detailWindowOpen = true;
                
                // NEU: Aktuelle Werte anzeigen
                updateDetailWindow();
                
                // NEU: Labels f√ºr aktuelle Rotation setzen
                updateRotationLabels(rotationAngle);
                
                // NEU: Button-Status setzen
                updateRotationButtons(rotationAngle);
                
                console.log("üîç Audio-Detailfenster ge√∂ffnet");
            }
        }

        // NEUE FUNKTION: Benutzerdefinierte Audio-Modifikationen anwenden
        function applyCustomAudioModifications() {
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    // NEU: Punktgr√∂√üe basierend auf benutzerdefinierten Modifikationen
                    const basePointSize = parseFloat(document.getElementById('pointSize').value);
                    const newPointSize = basePointSize * customAudioModifications.pointSizeMultiplier;
                    child.material.size = newPointSize;
                    
                    // NEU: Scale basierend auf Depth-Influence
                    const scaleFactor = customAudioModifications.depthInfluenceMultiplier;
                    child.scale.setScalar(scaleFactor);
                    
                    // NEU: Rotation basierend auf Consistency
                    if (customAudioModifications.consistencyMultiplier > 0.7) {
                        child.rotation.y += 0.01; // Mehr Rotation f√ºr "Scattered"
                    }
                }
            });
        }

        // MODIFIZIERTE FUNKTION: Point Cloud mit benutzerdefinierten Modifikationen erstellen
        function createPointCloudInScene(pointCloudData, position) {
            if (!pointCloudData) return;
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(pointCloudData.positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(pointCloudData.colors, 3));
            
            // NEU: Punktgr√∂√üe basierend auf benutzerdefinierten Modifikationen
            let pointSize = parseFloat(document.getElementById('pointSize').value);
            if (pointCloudData.metadata && pointCloudData.metadata.pointSizeMultiplier) {
                pointSize *= pointCloudData.metadata.pointSizeMultiplier;
            }
            
            // NEU: Benutzerdefinierte Modifikationen anwenden
            pointSize *= customAudioModifications.pointSizeMultiplier;
            
            const material = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });
            
            const pointCloud = new THREE.Points(geometry, material);
            pointCloud.position.set(0, 0, 0);
            
            // NEU: Scale basierend auf benutzerdefinierten Modifikationen
            const scaleFactor = customAudioModifications.depthInfluenceMultiplier;
            pointCloud.scale.setScalar(scaleFactor);
            
            scene.add(pointCloud);
            
            const pointCloudObject = {
                mesh: pointCloud,
                geometry: geometry,
                material: material,
                originalVertices: [...pointCloudData.positions],
                audioAnalysis: pointCloudData.metadata?.audioAnalysis,
                update: () => {
                    // NEU: Sanfte Rotation basierend auf Consistency
                    if (customAudioModifications.consistencyMultiplier > 0.7) {
                        pointCloud.rotation.y += 0.001;
                    }
                }
            };
            
            objectsToUpdate.push(pointCloudObject);
            
            // Verbesserte Kamera-Positionierung f√ºr Panoramen
            if (pointCloudData.metadata && pointCloudData.metadata.gps3DPosition) {
                const gpsPos = pointCloudData.metadata.gps3DPosition;
                console.log("üéØ Zentriere Kamera auf Panorama bei:", gpsPos);
                
                camera.position.set(gpsPos.x + 10, gpsPos.y + 10, gpsPos.z + 10);
                camera.lookAt(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.target.set(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.update();
                
                console.log("üì∑ Kamera auf Panorama zentriert");
            }
            
            console.log("Point Cloud zur Szene hinzugef√ºgt bei GPS-Position:", pointCloudData.metadata.gps3DPosition);
            console.log("Point Cloud Punkte:", pointCloudData.count);
            console.log("üéõÔ∏è  Benutzerdefinierte Modifikationen angewendet:", customAudioModifications);
            
            showStatus(`${pointCloudData.count.toLocaleString()} Punkte erstellt!`, 'success');
        }

        // NEUE FUNKTION: Detailfenster-Steuerung initialisieren
        function initDetailWindowControls() {
            const detailWindow = document.getElementById('audio-detail-window');
            if (!detailWindow) return;
            
            let isDragging = false;
            let startAngle = 0;
            let currentRotation = 0;
            
            // NEU: Touch- und Mouse-Events f√ºr Rotation
            detailWindow.addEventListener('mousedown', startRotation);
            detailWindow.addEventListener('touchstart', startRotation);
            
            document.addEventListener('mousemove', handleRotation);
            document.addEventListener('touchmove', handleRotation);
            
            document.addEventListener('mouseup', stopRotation);
            document.addEventListener('touchend', stopRotation);
            
            // NEU: Schlie√üen-Button
            const closeBtn = document.getElementById('audio-detail-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    detailWindow.style.display = 'none';
                });
            }
            
            function startRotation(e) {
                e.preventDefault();
                isDragging = true;
                const rect = detailWindow.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                startAngle = Math.atan2(clientY - centerY, clientX - centerX);
            }
            
            function handleRotation(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const rect = detailWindow.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const currentAngle = Math.atan2(clientY - centerY, clientX - centerX);
                const deltaAngle = currentAngle - startAngle;
                
                // NEU: Nur Vierteldrehungen (90¬∞ Schritte) erlauben
                const targetRotation = Math.round((currentRotation + deltaAngle) / (Math.PI / 2)) * (Math.PI / 2);
                
                if (Math.abs(targetRotation - currentRotation) > 0.1) {
                    currentRotation = targetRotation;
                    rotateDetailWindow(currentRotation);
                    updateAudioInfluences(currentRotation);
                }
            }
            
            function stopRotation() {
                isDragging = false;
            }
        }

        // NEUE FUNKTION: Detailfenster rotieren
        function rotateDetailWindow(angle) {
            const outerCircle = document.getElementById('audio-detail-outer-circle');
            if (outerCircle) {
                outerCircle.style.transform = `rotate(${angle}rad)`;
            }
        }

        // NEUE FUNKTION: Audio-Einfl√ºsse basierend auf Rotation aktualisieren
        function updateAudioInfluences(rotation) {
            // NEU: Berechne neue Mapping-Werte basierend auf Rotation
            const rotationDegrees = (rotation * 180) / Math.PI;
            const quarter = Math.round(rotationDegrees / 90) % 4;
            
            console.log(`üîÑ Rotation: ${rotationDegrees.toFixed(0)}¬∞ (Viertel: ${quarter})`);
            
            // NEU: Mapping basierend auf Vierteldrehung
            switch (quarter) {
                case 0: // Original
                    audioInfluences = {
                        loudToSize: 'large',
                        quietToSize: 'small',
                        scatteredToDepth: 'extreme',
                        sortedToDepth: 'flat'
                    };
                    break;
                case 1: // 90¬∞ gedreht
                    audioInfluences = {
                        loudToSize: 'small',
                        quietToSize: 'large',
                        scatteredToDepth: 'flat',
                        sortedToDepth: 'extreme'
                    };
                    break;
                case 2: // 180¬∞ gedreht
                    audioInfluences = {
                        loudToSize: 'small',
                        quietToSize: 'large',
                        scatteredToDepth: 'extreme',
                        sortedToDepth: 'flat'
                    };
                    break;
                case 3: // 270¬∞ gedreht
                    audioInfluences = {
                        loudToSize: 'large',
                        quietToSize: 'small',
                        scatteredToDepth: 'flat',
                        sortedToDepth: 'extreme'
                    };
                    break;
            }
            
            console.log("üéõÔ∏è Neue Audio-Einfl√ºsse:", audioInfluences);
            
            // NEU: Sofortige Anwendung auf aktuelle Panoramen
            applyAudioInfluencesToCurrentPanoramas();
        }

        // NEUE FUNKTION: Audio-Einfl√ºsse auf aktuelle Panoramen anwenden
        function applyAudioInfluencesToCurrentPanoramas() {
            // NEU: Alle aktuellen Point Clouds neu rendern mit neuen Einfl√ºssen
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.userData.isAudioModified) {
                    // NEU: Point Cloud mit neuen Audio-Einfl√ºssen neu erstellen
                    recreatePointCloudWithAudioInfluences(child);
                }
            });
        }

        // MODIFIZIERTE FUNKTION: Audio-Animation OHNE ROTATION
        function animatePointCloudWithAudio(currentTime, timeBasedDbMap, recordingDuration) {
            if (!timeBasedDbMap || !recordingDuration) return;
            
            // Normalisierte Zeit (0-1)
            const normalizedTime = (currentTime % recordingDuration) / recordingDuration;
            
            // Finde den aktuellen DB-Level f√ºr diese Zeit
            const timeIndex = Math.floor(normalizedTime * timeBasedDbMap.length);
            const clampedTimeIndex = Math.max(0, Math.min(timeBasedDbMap.length - 1, timeIndex));
            const currentDbLevel = timeBasedDbMap[clampedTimeIndex].dbLevel;
            
            // NEU: Dynamische Animation f√ºr alle Point Clouds (OHNE ROTATION)
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    // NEU: Bewegung basierend auf DB-Level (NUR SKALIERUNG UND POSITION)
                    const movementIntensity = currentDbLevel * 3.0; // 0-3x Bewegung
                    
                    // NEU: Verschiedene Bewegungsarten basierend auf DB-Level (OHNE ROTATION)
                    if (currentDbLevel > 0.7) {
                        // LAUT: Nur Pulsierende Skalierung (KEINE ROTATION)
                        const pulseScale = 1.0 + Math.sin(Date.now() * 0.01) * 0.2 * movementIntensity;
                        child.scale.setScalar(pulseScale);
                        
                    } else if (currentDbLevel > 0.4) {
                        // MITTEL: Sanfte Skalierung (KEINE ROTATION)
                        const gentleScale = 1.0 + Math.sin(Date.now() * 0.005) * 0.1 * movementIntensity;
                        child.scale.setScalar(gentleScale);
                        
                    } else {
                        // LEISE: Keine Bewegung (KEINE ROTATION)
                        child.scale.setScalar(1.0);
                    }
                    
                    // NEU: Position-Bewegung f√ºr sehr laute Bereiche (OHNE ROTATION)
                    if (currentDbLevel > 0.8) {
                        const wobbleX = Math.sin(Date.now() * 0.02) * 0.5 * movementIntensity;
                        const wobbleY = Math.cos(Date.now() * 0.015) * 0.3 * movementIntensity;
                        child.position.x += wobbleX * 0.01;
                        child.position.y += wobbleY * 0.01;
                    }
                }
            });
            
            // Debug-Ausgabe f√ºr laute Bereiche
            if (currentDbLevel > 0.6) {
                console.log(`üéµ Audio-Animation: DB=${currentDbLevel.toFixed(2)}, Bewegung=${movementIntensity.toFixed(2)}x`);
            }
        }

        // MODIFIZIERTE FUNKTION: Point Cloud mit benutzerdefinierten Modifikationen erstellen (OHNE ROTATION)
        function createPointCloudInScene(pointCloudData, position) {
            if (!pointCloudData) return;
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(pointCloudData.positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(pointCloudData.colors, 3));
            
            // NEU: Punktgr√∂√üe basierend auf benutzerdefinierten Modifikationen
            let pointSize = parseFloat(document.getElementById('pointSize').value);
            if (pointCloudData.metadata && pointCloudData.metadata.pointSizeMultiplier) {
                pointSize *= pointCloudData.metadata.pointSizeMultiplier;
            }
            
            // NEU: Benutzerdefinierte Modifikationen anwenden
            pointSize *= customAudioModifications.pointSizeMultiplier;
            
            const material = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });
            
            const pointCloud = new THREE.Points(geometry, material);
            pointCloud.position.set(0, 0, 0);
            
            // NEU: Scale basierend auf benutzerdefinierten Modifikationen
            const scaleFactor = customAudioModifications.depthInfluenceMultiplier;
            pointCloud.scale.setScalar(scaleFactor);
            
            scene.add(pointCloud);
            
            const pointCloudObject = {
                mesh: pointCloud,
                geometry: geometry,
                material: material,
                originalVertices: [...pointCloudData.positions],
                audioAnalysis: pointCloudData.metadata?.audioAnalysis,
                update: () => {
                    // NEU: KEINE ROTATION MEHR
                    // Point Cloud bleibt statisch
                }
            };
            
            objectsToUpdate.push(pointCloudObject);
            
            // Verbesserte Kamera-Positionierung f√ºr Panoramen
            if (pointCloudData.metadata && pointCloudData.metadata.gps3DPosition) {
                const gpsPos = pointCloudData.metadata.gps3DPosition;
                console.log("üéØ Zentriere Kamera auf Panorama bei:", gpsPos);
                
                camera.position.set(gpsPos.x + 10, gpsPos.y + 10, gpsPos.z + 10);
                camera.lookAt(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.target.set(gpsPos.x, gpsPos.y, gpsPos.z);
                controls.update();
                
                console.log("üì∑ Kamera auf Panorama zentriert");
            }
            
            console.log("Point Cloud zur Szene hinzugef√ºgt bei GPS-Position:", pointCloudData.metadata.gps3DPosition);
            console.log("Point Cloud Punkte:", pointCloudData.count);
            console.log("üéõÔ∏è  Benutzerdefinierte Modifikationen angewendet:", customAudioModifications);
            
            showStatus(`${pointCloudData.count.toLocaleString()} Punkte erstellt!`, 'success');
        }

        // MODIFIZIERTE FUNKTION: Benutzerdefinierte Audio-Modifikationen anwenden (OHNE ROTATION)
        function applyCustomAudioModifications() {
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    // NEU: Punktgr√∂√üe basierend auf benutzerdefinierten Modifikationen
                    const basePointSize = parseFloat(document.getElementById('pointSize').value);
                    const newPointSize = basePointSize * customAudioModifications.pointSizeMultiplier;
                    child.material.size = newPointSize;
                    
                    // NEU: Scale basierend auf Depth-Influence
                    const scaleFactor = customAudioModifications.depthInfluenceMultiplier;
                    child.scale.setScalar(scaleFactor);
                    
                    // NEU: KEINE ROTATION MEHR
                    // Point Cloud bleibt statisch
                }
            });
        }

        // MODIFIZIERTE FUNKTION: Audio-basierte Modifikationen anwenden (OHNE ROTATION)
        function applyAudioBasedModifications() {
            scene.children.forEach(child => {
                if (child.type === 'Points' && child.material) {
                    // NEU: Nur Skalierung und Position, KEINE ROTATION
                    const dbLevel = child.userData.dbLevel || 0.5;
                    
                    // NEU: Skalierung basierend auf DB-Level
                    const scaleFactor = 0.5 + (dbLevel * 1.5); // 0.5 - 2.0
                    child.scale.setScalar(scaleFactor);
                    
                    // NEU: Position-Bewegung f√ºr laute Ger√§usche (OHNE ROTATION)
                    if (dbLevel > 0.7) {
                        const wobbleX = Math.sin(Date.now() * 0.02) * 0.5;
                        const wobbleY = Math.cos(Date.now() * 0.015) * 0.3;
                        child.position.x += wobbleX * 0.01;
                        child.position.y += wobbleY * 0.01;
                    }
                    
                    // NEU: KEINE ROTATION MEHR
                }
            });
        }
    </script>
</body>
</html> 